[
  {
    "schema": "public",
    "function_name": "get_filtered_exercises",
    "definition": "CREATE OR REPLACE FUNCTION public.get_filtered_exercises(p_search_term text DEFAULT NULL::text, p_primary_intents text[] DEFAULT NULL::text[], p_tag_ids integer[] DEFAULT NULL::integer[], p_difficulty_level integer DEFAULT NULL::integer, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0)\n RETURNS SETOF exercises\n LANGUAGE sql\nAS $function$\r\n    SELECT *\r\n    FROM exercises e\r\n    WHERE\r\n        -- Conditional search term filter\r\n        (p_search_term IS NULL OR e.name ILIKE ('%' || p_search_term || '%'))\r\n        -- Conditional difficulty filter\r\n        AND (p_difficulty_level IS NULL OR e.difficulty_level = p_difficulty_level)\r\n        -- NEW: Conditional primary physical intent filter\r\n        AND (p_primary_intents IS NULL OR e.primary_physical_intent::TEXT = ANY(p_primary_intents))\r\n        -- NEW: Conditional tag filter (for equipment, mental attributes, etc.)\r\n        AND (p_tag_ids IS NULL OR EXISTS (\r\n            SELECT 1 FROM exercise_tags et\r\n            WHERE et.exercise_id = e.id AND et.tag_id = ANY(p_tag_ids)\r\n        ))\r\n    ORDER BY e.name\r\n    LIMIT p_page_limit\r\n    OFFSET p_page_offset;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "mark_abandoned_plans",
    "definition": "CREATE OR REPLACE FUNCTION public.mark_abandoned_plans()\n RETURNS void\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\r\n    UPDATE public.user_plan_status\r\n    SET status = 'abandoned'\r\n    WHERE\r\n        status = 'active'\r\n        -- CORRECTED LOGIC: Find plans where the last activity\r\n        -- was more than 2 days (48 hours) ago.\r\n        AND last_activity_at < now() - interval '2 days';\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "invite_member_to_team",
    "definition": "CREATE OR REPLACE FUNCTION public.invite_member_to_team(p_team_id uuid, p_role team_member_role, p_invited_user_id uuid DEFAULT NULL::uuid, p_invited_email text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_inviter_id UUID := auth.uid();\r\n    v_final_user_id UUID := p_invited_user_id;\r\n    v_final_email TEXT := p_invited_email;\r\n    v_inviter_role team_member_role;\r\n    v_new_invitation_id UUID;\r\nBEGIN\r\n    -- ... (All security checks and logic are exactly the same as before) ...\r\n    IF p_invited_user_id IS NULL AND p_invited_email IS NULL THEN\r\n        RAISE EXCEPTION 'Either a user ID or an email must be provided.';\r\n    END IF;\r\n    SELECT role INTO v_inviter_role FROM public.team_members WHERE team_id = p_team_id AND user_id = v_inviter_id;\r\n    IF v_inviter_role IS NULL OR v_inviter_role NOT IN ('admin', 'coach') THEN\r\n        RAISE EXCEPTION 'Permission denied: Not an admin or coach of this team.';\r\n    END IF;\r\n    IF v_final_user_id IS NOT NULL THEN\r\n        SELECT email INTO v_final_email FROM auth.users WHERE id = v_final_user_id;\r\n        IF v_final_email IS NULL THEN RAISE EXCEPTION 'Invited user not found.'; END IF;\r\n    ELSE\r\n        SELECT id INTO v_final_user_id FROM auth.users WHERE email = v_final_email;\r\n    END IF;\r\n    IF v_final_user_id IS NOT NULL AND EXISTS (SELECT 1 FROM public.team_members WHERE team_id = p_team_id AND user_id = v_final_user_id) THEN\r\n        RAISE EXCEPTION 'This user is already a member of the team.';\r\n    END IF;\r\n\r\n    -- Create the invitation and capture the new ID\r\n    INSERT INTO public.team_invitations (team_id, invited_by, invited_email, invited_user_id, role)\r\n    VALUES (p_team_id, v_inviter_id, v_final_email, v_final_user_id, p_role)\r\n    RETURNING id INTO v_new_invitation_id;\r\n\r\n    -- THE KEY CHANGE: Return a structured JSON object with the ID.\r\n    RETURN jsonb_build_object('id', v_new_invitation_id);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "log_workout_session",
    "definition": "CREATE OR REPLACE FUNCTION public.log_workout_session(p_session_log_id uuid, p_performed_exercises jsonb, p_duration_minutes integer, p_overall_feeling smallint, p_notes text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    exercise_data jsonb;\r\n    set_data jsonb;\r\n    new_session_exercise_log_id uuid;\r\nBEGIN\r\n    -- First, loop through each performed exercise in the JSON array\r\n    FOR exercise_data IN SELECT * FROM jsonb_array_elements(p_performed_exercises)\r\n    LOOP\r\n        -- Create a parent log entry for this exercise\r\n        INSERT INTO public.session_exercise_logs\r\n            (session_log_id, plan_session_exercise_id, exercise_id, notes)\r\n        VALUES\r\n            (p_session_log_id,\r\n             (exercise_data->>'plan_session_exercise_id')::uuid,\r\n             (exercise_data->>'exercise_id')::uuid,\r\n             exercise_data->>'notes'\r\n            )\r\n        RETURNING id INTO new_session_exercise_log_id;\r\n\r\n        -- Then, loop through each set for this exercise\r\n        FOR set_data IN SELECT * FROM jsonb_array_elements(exercise_data->'sets')\r\n        LOOP\r\n            INSERT INTO public.set_logs\r\n                (session_exercise_log_id, set_number, reps_performed, weight_used, duration_seconds, distance_meters, notes, performance_metadata)\r\n            VALUES\r\n                (new_session_exercise_log_id,\r\n                 (set_data->>'set_number')::smallint,\r\n                 (set_data->>'reps_performed')::smallint,\r\n                 (set_data->>'weight_used')::numeric,\r\n                 (set_data->>'duration_seconds')::integer,\r\n                 (set_data->>'distance_meters')::numeric,\r\n                 set_data->>'notes',\r\n                 set_data->'performance_metadata'\r\n                );\r\n        END LOOP;\r\n    END LOOP;\r\n\r\n    -- Finally, update the main session_log to mark it as complete\r\n    UPDATE public.session_logs\r\n    SET\r\n        status = 'completed',\r\n        duration_minutes = p_duration_minutes,\r\n        overall_feeling = p_overall_feeling,\r\n        notes = p_notes,\r\n        updated_at = now()\r\n    WHERE\r\n        id = p_session_log_id AND user_id = auth.uid();\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "start_user_plan",
    "definition": "CREATE OR REPLACE FUNCTION public.start_user_plan(p_plan_id uuid)\n RETURNS void\n LANGUAGE sql\nAS $function$\r\n    -- This uses the UNIQUE INDEX we created. It tries to insert a new 'active' plan.\r\n    -- If the user already has an active plan (violating the index), it updates\r\n    -- the existing row to point to this new plan instead.\r\n    INSERT INTO public.user_plan_status (user_id, plan_id, status, last_activity_at)\r\n    VALUES (auth.uid(), p_plan_id, 'active', now())\r\n    ON CONFLICT (user_id) WHERE (status = 'active')\r\n    DO UPDATE SET\r\n        plan_id = EXCLUDED.plan_id,\r\n        started_at = now(),\r\n        last_activity_at = now();\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "handle_new_user",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  _username_base TEXT := COALESCE(NEW.raw_user_meta_data ->> 'username', split_part(NEW.email, '@', 1));\r\n  _full_name TEXT := NEW.raw_user_meta_data ->> 'full_name';\r\n  _final_username TEXT;\r\n  _new_team_id UUID;\r\nBEGIN\r\n  -- 1. Create a guaranteed unique username.\r\n  _final_username := _username_base || '_' || substr(md5(random()::text), 1, 6);\r\n\r\n  -- 2. Create the user's profile.\r\n  INSERT INTO public.profiles (id, username, full_name, email)\r\n  VALUES (NEW.id, _final_username, _full_name, NEW.email);\r\n\r\n  -- 3. Create the user's protected \"Home Workspace\" team.\r\n  INSERT INTO public.teams (name, created_by, is_personal_workspace)\r\n  VALUES (_final_username || '''s Workspace', NEW.id, true)\r\n  RETURNING id INTO _new_team_id;\r\n\r\n  -- 4. Make the user the admin of their new workspace.\r\n  -- This step is now safe because the conflicting trigger and FK are gone.\r\n  INSERT INTO public.team_members (user_id, team_id, role)\r\n  VALUES (NEW.id, _new_team_id, 'admin');\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_team_details_and_members",
    "definition": "CREATE OR REPLACE FUNCTION public.get_team_details_and_members(p_team_id uuid)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT jsonb_build_object(\r\n        'team', to_jsonb(t),\r\n        'members', (\r\n            SELECT jsonb_agg(jsonb_build_object('profile', p, 'role', tm.role) ORDER BY tm.role, p.full_name)\r\n            FROM team_members tm\r\n            JOIN profiles p ON tm.user_id = p.id\r\n            WHERE tm.team_id = p_team_id\r\n        ),\r\n        'plans', (\r\n            SELECT jsonb_agg(p ORDER BY p.title)\r\n            FROM plans p\r\n            WHERE p.team_id = p_team_id\r\n        ),\r\n        -- NEW: Add the current user's role within this team.\r\n        -- This makes the function a complete replacement for get_workspace_data.\r\n        'current_user_role', (\r\n            SELECT tm.role\r\n            FROM team_members tm\r\n            WHERE tm.team_id = p_team_id AND tm.user_id = auth.uid()\r\n        )\r\n    )\r\n    FROM teams t\r\n    WHERE t.id = p_team_id;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_client_progress_for_coach",
    "definition": "CREATE OR REPLACE FUNCTION public.get_client_progress_for_coach(p_client_id uuid)\n RETURNS SETOF session_logs\n LANGUAGE sql\nAS $function$\r\n    SELECT sl.*\r\n    FROM session_logs sl\r\n    WHERE sl.user_id = p_client_id\r\n      -- SECURITY CHECK: This query will only return rows if the person calling the function...\r\n      AND EXISTS (\r\n        SELECT 1\r\n        FROM team_members caller_membership\r\n        JOIN team_members client_membership ON caller_membership.team_id = client_membership.team_id\r\n        WHERE\r\n            -- ...is a coach or admin in the same team as the client.\r\n            caller_membership.user_id = auth.uid()\r\n            AND client_membership.user_id = p_client_id\r\n            AND caller_membership.role IN ('admin', 'coach')\r\n      );\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_plan_user_performance_list",
    "definition": "CREATE OR REPLACE FUNCTION public.get_plan_user_performance_list(p_plan_id uuid)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT\r\n        jsonb_agg(\r\n            jsonb_build_object(\r\n                'profile', to_jsonb(prof),\r\n                'performance', to_jsonb(uperf)\r\n            )\r\n            ORDER BY uperf.goal_achievement_percentage DESC, uperf.completion_percentage DESC, uperf.last_activity_date DESC\r\n        )\r\n    FROM public.user_plan_performance_summary uperf\r\n    JOIN public.profiles prof ON uperf.user_id = prof.id\r\n    WHERE uperf.plan_id = p_plan_id;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "fork_plan",
    "definition": "CREATE OR REPLACE FUNCTION public.fork_plan(p_original_plan_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _caller_id uuid := auth.uid();\r\n    _original_plan record;\r\n    _new_plan_id uuid;\r\n    week_record record;\r\n    day_record record;\r\n    session_record record;\r\n    exercise_record record;\r\n    _new_week_id uuid;\r\n    _new_day_id uuid;\r\n    _new_session_id uuid;\r\n    _new_exercise_id uuid;\r\nBEGIN\r\n    -- Validate access and fetch original plan\r\n    SELECT * INTO _original_plan FROM public.plans WHERE id = p_original_plan_id;\r\n    IF NOT FOUND THEN RAISE EXCEPTION 'Original plan not found'; END IF;\r\n    IF _original_plan.private = true AND _original_plan.created_by <> _caller_id AND NOT _original_plan.allow_public_forking THEN RAISE EXCEPTION 'Permission denied: This plan cannot be forked'; END IF;\r\n\r\n    -- 1. Create the new forked plan record\r\n    INSERT INTO public.plans (title, description, difficulty_level, created_by, private, forked_from, allow_public_forking)\r\n    VALUES ('Fork of ' || _original_plan.title, _original_plan.description, _original_plan.difficulty_level, _caller_id, true, p_original_plan_id, false)\r\n    RETURNING id INTO _new_plan_id;\r\n\r\n    -- 2. Copy all plan goals\r\n    INSERT INTO public.plan_goals (plan_id, title, description, metric, target_value, exercise_id)\r\n    SELECT _new_plan_id, title, description, metric, target_value, exercise_id\r\n    FROM public.plan_goals WHERE plan_id = p_original_plan_id;\r\n\r\n    -- 3. Loop through and deep copy the hierarchy\r\n    FOR week_record IN SELECT * FROM public.plan_weeks WHERE plan_id = p_original_plan_id ORDER BY week_number LOOP\r\n        INSERT INTO public.plan_weeks (plan_id, week_number, description)\r\n        VALUES (_new_plan_id, week_record.week_number, week_record.description)\r\n        RETURNING id INTO _new_week_id;\r\n\r\n        FOR day_record IN SELECT * FROM public.plan_days WHERE plan_week_id = week_record.id ORDER BY day_number LOOP\r\n            INSERT INTO public.plan_days (plan_week_id, day_number, title, description, is_rest_day)\r\n            VALUES (_new_week_id, day_record.day_number, day_record.title, day_record.description, day_record.is_rest_day)\r\n            RETURNING id INTO _new_day_id;\r\n\r\n            FOR session_record IN SELECT * FROM public.plan_sessions WHERE plan_day_id = day_record.id ORDER BY order_index LOOP\r\n                INSERT INTO public.plan_sessions (plan_day_id, order_index, title, notes)\r\n                VALUES (_new_day_id, session_record.order_index, session_record.title, session_record.notes)\r\n                RETURNING id INTO _new_session_id;\r\n\r\n                FOR exercise_record IN SELECT * FROM public.plan_session_exercises WHERE plan_session_id = session_record.id ORDER BY order_within_session LOOP\r\n                    INSERT INTO public.plan_session_exercises (plan_session_id, exercise_id, order_within_session, notes, execution_group, post_exercise_rest_seconds, post_group_rest_seconds)\r\n                    VALUES (_new_session_id, exercise_record.exercise_id, exercise_record.order_within_session, exercise_record.notes, exercise_record.execution_group, exercise_record.post_exercise_rest_seconds, exercise_record.post_group_rest_seconds)\r\n                    RETURNING id INTO _new_exercise_id;\r\n\r\n                    -- Copy all sets for the exercise\r\n                    INSERT INTO public.plan_session_exercise_sets (plan_session_exercise_id, set_number, target_reps, target_weight, target_duration_seconds, target_distance_meters, notes, set_type, metadata)\r\n                    SELECT _new_exercise_id, set_number, target_reps, target_weight, target_duration_seconds, target_distance_meters, notes, set_type, metadata\r\n                    FROM public.plan_session_exercise_sets WHERE plan_session_exercise_id = exercise_record.id;\r\n                END LOOP;\r\n            END LOOP;\r\n        END LOOP;\r\n    END LOOP;\r\n\r\n    -- 4. Increment the fork count on the original plan\r\n    UPDATE public.plans SET fork_count = fork_count + 1 WHERE id = p_original_plan_id;\r\n\r\n    RETURN _new_plan_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_workout_details",
    "definition": "CREATE OR REPLACE FUNCTION public.get_workout_details(p_log_id uuid)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\r\nSELECT\r\n    jsonb_build_object(\r\n        'log_summary', to_jsonb(sl),\r\n        'performed_exercises', (\r\n            SELECT jsonb_agg(\r\n                jsonb_build_object(\r\n                    'exercise_details', to_jsonb(ex),\r\n                    'log_details', to_jsonb(sel),\r\n                    'sets_logged', (\r\n                        SELECT jsonb_agg(slog ORDER BY slog.set_number)\r\n                        FROM set_logs slog\r\n                        WHERE slog.session_exercise_log_id = sel.id\r\n                    )\r\n                )\r\n            )\r\n            FROM session_exercise_logs sel\r\n            JOIN exercises ex ON sel.exercise_id = ex.id\r\n            WHERE sel.session_log_id = sl.id\r\n        )\r\n    )\r\nFROM\r\n    session_logs sl\r\nWHERE\r\n    sl.id = p_log_id;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_filtered_users_rich",
    "definition": "CREATE OR REPLACE FUNCTION public.get_filtered_users_rich(p_search_term text DEFAULT NULL::text, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT jsonb_agg(user_data)\r\n    FROM (\r\n        SELECT\r\n            p.*,\r\n            to_jsonb(cas) as analytics\r\n        FROM profiles p\r\n        -- This join ensures we only get users who have created public content\r\n        -- and have analytics available.\r\n        JOIN coach_analytics_summary cas ON p.id = cas.coach_id\r\n        WHERE\r\n            (p_search_term IS NULL OR p.full_name ILIKE ('%' || p_search_term || '%') OR p.username ILIKE ('%' || p_search_term || '%'))\r\n        ORDER BY cas.total_likes_on_plans DESC NULLS LAST, p.full_name\r\n        LIMIT p_page_limit\r\n        OFFSET p_page_offset\r\n    ) AS user_data;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_new_team",
    "definition": "CREATE OR REPLACE FUNCTION public.create_new_team(p_name text, p_description text DEFAULT NULL::text, p_sport text DEFAULT NULL::text, p_is_private boolean DEFAULT false)\n RETURNS SETOF teams\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_user_id UUID := auth.uid();\r\n    new_team teams;\r\nBEGIN\r\n    -- Step 1: Create the new team record.\r\n    -- The 'is_personal_workspace' flag defaults to FALSE, so this is a collaborative team.\r\n    INSERT INTO public.teams (name, description, sport, is_private, created_by)\r\n    VALUES (p_name, p_description, p_sport, p_is_private, v_user_id)\r\n    RETURNING * INTO new_team;\r\n\r\n    -- Step 2: Make the creator of the team an 'admin'.\r\n    INSERT INTO public.team_members (team_id, user_id, role)\r\n    VALUES (new_team.id, v_user_id, 'admin');\r\n\r\n    -- Step 3: Return the newly created team record.\r\n    RETURN NEXT new_team;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_filtered_teams_rich",
    "definition": "CREATE OR REPLACE FUNCTION public.get_filtered_teams_rich(p_search_term text DEFAULT NULL::text, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT jsonb_agg(team_data)\r\n    FROM (\r\n        SELECT\r\n            t.*,\r\n            -- We can eventually add a team_analytics_summary view here\r\n            (SELECT COUNT(*) FROM team_members tm WHERE tm.team_id = t.id) as members_count,\r\n            (SELECT COUNT(*) FROM plans p WHERE p.team_id = t.id AND p.private = false) as plans_count\r\n        FROM teams t\r\n        WHERE\r\n            t.is_private = false\r\n            AND t.is_personal_workspace = false\r\n            AND (p_search_term IS NULL OR t.name ILIKE ('%' || p_search_term || '%'))\r\n        ORDER BY t.created_at DESC\r\n        LIMIT p_page_limit\r\n        OFFSET p_page_offset\r\n    ) AS team_data;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_plan_details_for_user",
    "definition": "CREATE OR REPLACE FUNCTION public.get_plan_details_for_user(p_plan_id uuid)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT\r\n        jsonb_build_object(\r\n            'plan', to_jsonb(p),\r\n            'creator', to_jsonb(creator_profile),\r\n            'team', to_jsonb(t),\r\n            'goals', (SELECT jsonb_agg(g) FROM plan_goals g WHERE g.plan_id = p.id),\r\n            'can_edit', (p.created_by = auth.uid() OR (p.team_id IS NOT NULL AND EXISTS (SELECT 1 FROM team_members tm WHERE tm.team_id = p.team_id AND tm.user_id = auth.uid() AND tm.role IN ('admin', 'coach')))),\r\n            'required_equipment', (\r\n                SELECT jsonb_agg(DISTINCT t_equip)\r\n                FROM plan_weeks pw\r\n                JOIN plan_days pd ON pw.id = pd.plan_week_id\r\n                JOIN plan_sessions ps ON pd.id = ps.plan_day_id\r\n                JOIN plan_session_exercises pse ON ps.id = pse.plan_session_id\r\n                JOIN exercise_tags et ON pse.exercise_id = et.exercise_id\r\n                JOIN tags t_equip ON et.tag_id = t_equip.id\r\n                WHERE pw.plan_id = p.id AND t_equip.tag_type = 'equipment'\r\n            ),\r\n            'hierarchy', (\r\n                SELECT jsonb_build_object(\r\n                    'weeks', (\r\n                        SELECT jsonb_agg(weeks.w_json ORDER BY weeks.week_number)\r\n                        FROM (\r\n                            SELECT\r\n                                w.*,\r\n                                jsonb_build_object('days', (\r\n                                    SELECT jsonb_agg(days.d_json ORDER BY days.day_number)\r\n                                    FROM (\r\n                                        SELECT\r\n                                            d.*,\r\n                                            jsonb_build_object('sessions', (\r\n                                                SELECT jsonb_agg(sessions.s_json ORDER BY sessions.order_index)\r\n                                                FROM (\r\n                                                    SELECT\r\n                                                        s.*,\r\n                                                        jsonb_build_object(\r\n                                                            'is_completed_by_user', EXISTS(SELECT 1 FROM session_logs sl WHERE sl.user_id = auth.uid() AND sl.plan_session_id = s.id AND sl.status = 'completed'),\r\n                                                            'exercises', (\r\n                                                                SELECT jsonb_agg(exercises.pse_json ORDER BY exercises.order_within_session)\r\n                                                                FROM (\r\n                                                                    SELECT\r\n                                                                        -- THE CRITICAL FIX IS HERE: We now include all columns from pse\r\n                                                                        pse.*,\r\n                                                                        jsonb_build_object(\r\n                                                                            'exercise_details', to_jsonb(ex),\r\n                                                                            'sets', (SELECT jsonb_agg(pses ORDER BY pses.set_number) FROM plan_session_exercise_sets pses WHERE pses.plan_session_exercise_id = pse.id)\r\n                                                                        ) AS pse_json\r\n                                                                    FROM plan_session_exercises pse\r\n                                                                    JOIN exercises ex ON pse.exercise_id = ex.id\r\n                                                                    WHERE pse.plan_session_id = s.id\r\n                                                                ) AS exercises\r\n                                                            )\r\n                                                        ) AS s_json\r\n                                                    FROM plan_sessions s\r\n                                                    WHERE s.plan_day_id = d.id\r\n                                                ) AS sessions\r\n                                            )) AS d_json\r\n                                        FROM plan_days d\r\n                                        WHERE d.plan_week_id = w.id\r\n                                    ) AS days\r\n                                )) AS w_json\r\n                            FROM plan_weeks w\r\n                            WHERE w.plan_id = p.id\r\n                        ) AS weeks\r\n                    )\r\n                )\r\n            )\r\n        )\r\n    FROM\r\n        plans p\r\n    JOIN\r\n        profiles creator_profile ON p.created_by = creator_profile.id\r\n    LEFT JOIN\r\n        teams t ON p.team_id = t.id\r\n    WHERE\r\n        p.id = p_plan_id;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "complete_onboarding",
    "definition": "CREATE OR REPLACE FUNCTION public.complete_onboarding()\n RETURNS void\n LANGUAGE sql\nAS $function$\r\n    -- Find the profile record for the currently authenticated user\r\n    -- and update the onboarding_completed flag to TRUE.\r\n    UPDATE public.profiles\r\n    SET onboarding_completed = true\r\n    WHERE id = auth.uid();\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_user_dashboard_summary",
    "definition": "CREATE OR REPLACE FUNCTION public.get_user_dashboard_summary()\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    v_active_plan_id UUID;\r\n    v_result JSONB;\r\nBEGIN\r\n    -- First, find the user's active plan ID\r\n    SELECT plan_id INTO v_active_plan_id\r\n    FROM public.user_plan_status\r\n    WHERE user_id = auth.uid() AND status = 'active'\r\n    LIMIT 1;\r\n\r\n    -- Now, build the main JSONB object\r\n    SELECT jsonb_build_object(\r\n        -- NEW: If an active plan exists, call our powerful get_plan_details_for_user\r\n        -- function to get the rich, complete plan object.\r\n        'active_plan_details', (\r\n            SELECT\r\n                CASE\r\n                    WHEN v_active_plan_id IS NOT NULL THEN\r\n                        public.get_plan_details_for_user(v_active_plan_id)\r\n                    ELSE\r\n                        NULL\r\n                END\r\n        ),\r\n\r\n        -- The rest of the function remains the same as it was correct\r\n        'my_teams', (\r\n            SELECT jsonb_agg(\r\n                to_jsonb(t) || jsonb_build_object('role', tm.role)\r\n                ORDER BY t.name\r\n            )\r\n            FROM team_members tm\r\n            JOIN teams t ON tm.team_id = t.id\r\n            WHERE tm.user_id = auth.uid()\r\n        ),\r\n\r\n        'my_created_plans', (\r\n            SELECT jsonb_agg(p ORDER BY p.created_at DESC)\r\n            FROM plans p\r\n            WHERE p.created_by = auth.uid()\r\n        ),\r\n\r\n        'pending_invitations_count', (\r\n            SELECT COUNT(*)\r\n            FROM team_invitations ti\r\n            WHERE ti.invited_user_id = auth.uid() AND ti.status = 'pending'\r\n        )\r\n    ) INTO v_result;\r\n\r\n    RETURN v_result;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_user_profile_details",
    "definition": "CREATE OR REPLACE FUNCTION public.get_user_profile_details(p_user_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    v_active_plan_id UUID;\r\n    v_result JSONB;\r\nBEGIN\r\n    SELECT plan_id INTO v_active_plan_id\r\n    FROM public.user_plan_status\r\n    WHERE user_id = p_user_id AND status = 'active'\r\n    LIMIT 1;\r\n\r\n    -- This CTE is now corrected to use the right column name\r\n    WITH latest_activity AS (\r\n        SELECT\r\n            pw.week_number,\r\n            pd.day_number\r\n        FROM session_logs sl\r\n        -- CORRECTED JOIN: Use the new 'plan_session_id' column\r\n        JOIN plan_sessions ps ON sl.plan_session_id = ps.id\r\n        JOIN plan_days pd ON ps.plan_day_id = pd.id\r\n        JOIN plan_weeks pw ON pd.plan_week_id = pw.id\r\n        WHERE sl.user_id = p_user_id\r\n          AND pw.plan_id = v_active_plan_id\r\n        ORDER BY sl.date DESC, sl.created_at DESC\r\n        LIMIT 1\r\n    )\r\n    SELECT jsonb_build_object(\r\n        'profile', to_jsonb(prof),\r\n        'teams', (\r\n            SELECT jsonb_agg(jsonb_build_object('team', t, 'role', tm.role))\r\n            FROM team_members tm\r\n            JOIN teams t ON tm.team_id = t.id\r\n            WHERE tm.user_id = p_user_id\r\n        ),\r\n        'active_plan_details', (\r\n            -- This part correctly calls the other function, so it's fine.\r\n            SELECT\r\n                CASE\r\n                    WHEN v_active_plan_id IS NOT NULL THEN\r\n                        public.get_plan_details_for_user(v_active_plan_id)\r\n                    ELSE\r\n                        NULL\r\n                END\r\n        )\r\n    )\r\n    INTO v_result\r\n    FROM public.profiles prof\r\n    WHERE prof.id = p_user_id;\r\n\r\n    RETURN v_result;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_filtered_plans_rich",
    "definition": "CREATE OR REPLACE FUNCTION public.get_filtered_plans_rich(p_search_term text DEFAULT NULL::text, p_tag_ids integer[] DEFAULT NULL::integer[], p_difficulty_level integer DEFAULT NULL::integer, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT jsonb_agg(plan_data)\r\n    FROM (\r\n        SELECT\r\n            p.*,\r\n            -- This function now gets its analytics from the pre-calculated view\r\n            to_jsonb(pas) as analytics,\r\n            to_jsonb(creator) as creator\r\n        FROM plans p\r\n        JOIN profiles creator on p.created_by = creator.id\r\n        LEFT JOIN plan_analytics_summary pas ON p.id = pas.plan_id\r\n        WHERE\r\n            p.private = false\r\n            -- The WHERE clauses now filter based on the new structure\r\n            AND (p_search_term IS NULL OR p.title ILIKE ('%' || p_search_term || '%'))\r\n            AND (p_difficulty_level IS NULL OR p.difficulty_level = p.difficulty_level)\r\n            AND (p_tag_ids IS NULL OR EXISTS (\r\n                -- This subquery checks for exercises with the specified tags\r\n                SELECT 1 FROM plan_weeks pw\r\n                JOIN plan_days pd ON pw.id = pd.plan_week_id\r\n                JOIN plan_sessions ps ON pd.id = ps.plan_day_id\r\n                JOIN plan_session_exercises pse ON ps.id = pse.plan_session_id\r\n                JOIN exercise_tags et ON pse.exercise_id = et.exercise_id\r\n                WHERE pw.plan_id = p.id AND et.tag_id = ANY(p_tag_ids)\r\n            ))\r\n        ORDER BY pas.active_users_count DESC NULLS LAST, p.created_at DESC\r\n        LIMIT p_page_limit\r\n        OFFSET p_page_offset\r\n    ) AS plan_data;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_exercise_details",
    "definition": "CREATE OR REPLACE FUNCTION public.get_exercise_details(p_exercise_id uuid)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\r\n    SELECT\r\n        jsonb_build_object(\r\n            'exercise', to_jsonb(e),\r\n            'muscles', (\r\n                SELECT jsonb_agg(\r\n                    jsonb_build_object(\r\n                        'muscle', em.muscle_group,\r\n                        'engagement', em.engagement_level\r\n                    )\r\n                )\r\n                FROM exercise_muscle em\r\n                WHERE em.exercise_id = e.id\r\n            ),\r\n            'tags', (\r\n                SELECT jsonb_agg(t)\r\n                FROM exercise_tags et\r\n                JOIN tags t ON et.tag_id = t.id\r\n                WHERE et.exercise_id = e.id\r\n            ),\r\n            'references', (\r\n                 SELECT jsonb_agg(erg)\r\n                 FROM exercise_reference_global erg\r\n                 WHERE erg.exercise_id = e.id\r\n            )\r\n        )\r\n    FROM exercises e\r\n    WHERE e.id = p_exercise_id;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "respond_to_team_invitation",
    "definition": "CREATE OR REPLACE FUNCTION public.respond_to_team_invitation(p_invitation_id uuid, p_accepted boolean)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_invitation public.team_invitations;\r\n    v_user_id UUID := auth.uid();\r\nBEGIN\r\n    -- Fetch the invitation and verify the current user is the one invited.\r\n    SELECT * INTO v_invitation FROM public.team_invitations WHERE id = p_invitation_id;\r\n\r\n    IF v_invitation IS NULL THEN\r\n        RAISE EXCEPTION 'Invitation not found.';\r\n    END IF;\r\n\r\n    IF v_invitation.invited_user_id IS DISTINCT FROM v_user_id THEN\r\n        RAISE EXCEPTION 'Permission denied: This invitation is not for you.';\r\n    END IF;\r\n\r\n    IF v_invitation.status <> 'pending' THEN\r\n        RAISE EXCEPTION 'This invitation has already been responded to.';\r\n    END IF;\r\n\r\n    IF p_accepted THEN\r\n        -- User accepted: Update status and create the team membership.\r\n        UPDATE public.team_invitations SET status = 'accepted' WHERE id = p_invitation_id;\r\n        INSERT INTO public.team_members (team_id, user_id, role)\r\n        VALUES (v_invitation.team_id, v_user_id, v_invitation.role);\r\n    ELSE\r\n        -- User declined: Update status.\r\n        UPDATE public.team_invitations SET status = 'declined' WHERE id = p_invitation_id;\r\n    END IF;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_filtered_exercises",
    "definition": "CREATE OR REPLACE FUNCTION public.get_filtered_exercises(p_search_term text DEFAULT NULL::text, p_muscle_groups text[] DEFAULT NULL::text[], p_categories text[] DEFAULT NULL::text[], p_types text[] DEFAULT NULL::text[], p_environments text[] DEFAULT NULL::text[], p_difficulty_level integer DEFAULT NULL::integer, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0)\n RETURNS SETOF exercises\n LANGUAGE sql\nAS $function$\r\n    SELECT *\r\n    FROM exercises e\r\n    WHERE\r\n        -- Conditional search term filter\r\n        (p_search_term IS NULL OR e.name ILIKE ('%' || p_search_term || '%'))\r\n        -- Conditional difficulty filter\r\n        AND (p_difficulty_level IS NULL OR e.difficulty_level = p_difficulty_level)\r\n        -- Conditional environment filter\r\n        AND (p_environments IS NULL OR e.environment::TEXT = ANY(p_environments))\r\n        -- Conditional muscle group filter\r\n        AND (p_muscle_groups IS NULL OR EXISTS (\r\n            SELECT 1 FROM exercise_muscle em\r\n            WHERE em.exercise_id = e.id AND em.muscle_group::TEXT = ANY(p_muscle_groups)\r\n        ))\r\n        -- Conditional category filter\r\n        AND (p_categories IS NULL OR EXISTS (\r\n            SELECT 1 FROM exercise_to_category etc\r\n            WHERE etc.exercise_id = e.id AND etc.category::TEXT = ANY(p_categories)\r\n        ))\r\n        -- Conditional type filter\r\n        AND (p_types IS NULL OR EXISTS (\r\n            SELECT 1 FROM exercise_to_type ett\r\n            WHERE ett.exercise_id = e.id AND ett.type::TEXT = ANY(p_types)\r\n        ))\r\n    ORDER BY e.name\r\n    LIMIT p_page_limit\r\n    OFFSET p_page_offset;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "claim_pending_invitations",
    "definition": "CREATE OR REPLACE FUNCTION public.claim_pending_invitations()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  -- This function runs AFTER a new user's profile is created.\r\n  -- The 'NEW' variable holds the data for the new profile row.\r\n\r\n  -- Look for any pending invitations that match the new user's email\r\n  -- and update them with the new user's ID.\r\n  UPDATE public.team_invitations\r\n  SET invited_user_id = NEW.id\r\n  WHERE invited_email = NEW.email AND status = 'pending';\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_session_log",
    "definition": "CREATE OR REPLACE FUNCTION public.get_session_log(p_session_log_id uuid)\n RETURNS SETOF session_logs\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT *\r\n    FROM public.session_logs\r\n    WHERE id = p_session_log_id AND user_id = auth.uid();\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_user_plan_history",
    "definition": "CREATE OR REPLACE FUNCTION public.get_user_plan_history(p_user_id uuid)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\r\nSELECT\r\n    jsonb_agg(plan_history)\r\nFROM (\r\n    SELECT\r\n        p.*,\r\n        MIN(sl.date) as first_logged_date,\r\n        MAX(sl.date) as last_logged_date\r\n    FROM\r\n        session_logs sl\r\n        -- CORRECTED JOIN: Use the new 'plan_session_id' column\r\n        JOIN plan_sessions ps ON sl.plan_session_id = ps.id\r\n        JOIN plan_days pd ON ps.plan_day_id = pd.id\r\n        JOIN plan_weeks pw ON pd.plan_week_id = pw.id\r\n        JOIN plans p ON pw.plan_id = p.id\r\n    WHERE\r\n        sl.user_id = p_user_id\r\n        AND sl.plan_session_id IS NOT NULL\r\n    GROUP BY\r\n        p.id\r\n    ORDER BY\r\n        last_logged_date DESC\r\n) AS plan_history;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_discoverable_teams_rich",
    "definition": "CREATE OR REPLACE FUNCTION public.get_discoverable_teams_rich(p_search_term text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\r\nSELECT\r\n    jsonb_agg(t_agg)\r\nFROM (\r\n    SELECT\r\n        t.*,\r\n        (SELECT COUNT(*) FROM team_members tm WHERE tm.team_id = t.id) AS members_count,\r\n        (SELECT COUNT(*) FROM plans p WHERE p.team_id = t.id) AS plans_count,\r\n        \r\n        -- NEW: Get the full profiles of admins and coaches\r\n        (\r\n            SELECT jsonb_agg(jsonb_build_object('profile', p, 'role', tm.role))\r\n            FROM team_members tm\r\n            JOIN profiles p ON tm.user_id = p.id\r\n            WHERE tm.team_id = t.id AND tm.role IN ('admin', 'coach')\r\n        ) AS key_members,\r\n\r\n        -- NEW: Get a preview of up to 15 member names for tooltips\r\n        (\r\n            SELECT jsonb_agg(p.full_name)\r\n            FROM (\r\n                SELECT p_inner.*\r\n                FROM team_members tm\r\n                JOIN profiles p_inner ON tm.user_id = p_inner.id\r\n                WHERE tm.team_id = t.id\r\n                ORDER BY tm.role, p_inner.full_name\r\n                LIMIT 15\r\n            ) p\r\n        ) AS member_names_preview\r\n\r\n    FROM\r\n        teams t\r\n    WHERE\r\n        t.is_private = false\r\n        AND (\r\n            p_search_term IS NULL OR\r\n            t.name ILIKE ('%' || p_search_term || '%') OR\r\n            t.description ILIKE ('%' || p_search_term || '%')\r\n        )\r\n    ORDER BY\r\n        t.created_at DESC\r\n) AS t_agg;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "trigger_set_timestamp",
    "definition": "CREATE OR REPLACE FUNCTION public.trigger_set_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.updated_at = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "start_workout_session",
    "definition": "CREATE OR REPLACE FUNCTION public.start_workout_session(p_plan_session_id uuid)\n RETURNS SETOF session_logs\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_plan_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    new_session_log session_logs;\r\nBEGIN\r\n    IF p_plan_session_id IS NULL THEN\r\n        RAISE EXCEPTION 'A valid session ID must be provided to start a workout.';\r\n    END IF;\r\n\r\n    -- Find the top-level plan_id from the session_id\r\n    SELECT pw.plan_id INTO v_plan_id\r\n    FROM plan_sessions ps\r\n    JOIN plan_days pd ON ps.plan_day_id = pd.id\r\n    JOIN plan_weeks pw ON pd.plan_week_id = pw.id\r\n    WHERE ps.id = p_plan_session_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Plan not found for the provided session ID.';\r\n    END IF;\r\n\r\n    -- THE CRITICAL FIX IS HERE: This is a robust \"UPSERT\" operation.\r\n    -- We are telling Postgres: Try to insert a new 'active' status for this user.\r\n    -- If a row already exists for this user with an 'active' status (violating\r\n    -- a unique constraint), DON'T throw an error. Instead, DO an UPDATE on that\r\n    -- existing row.\r\n    INSERT INTO public.user_plan_status (user_id, plan_id, status)\r\n    VALUES (v_user_id, v_plan_id, 'active')\r\n    ON CONFLICT (user_id, status) WHERE status = 'active'\r\n    DO UPDATE SET\r\n        plan_id = EXCLUDED.plan_id,\r\n        last_activity_at = now();\r\n\r\n    -- Create the new session log record\r\n    INSERT INTO public.session_logs (user_id, plan_session_id, date, status, plan_id)\r\n    VALUES (v_user_id, p_plan_session_id, now(), 'in_progress', v_plan_id)\r\n    RETURNING * INTO new_session_log;\r\n\r\n    RETURN NEXT new_session_log;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "assign_team_plan_to_member",
    "definition": "CREATE OR REPLACE FUNCTION public.assign_team_plan_to_member(_user_id_to_assign uuid, _plan_id_to_assign uuid, _team_id_context uuid, _start_date date DEFAULT now(), _privacy_level character varying DEFAULT 'team'::character varying)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  _caller_id uuid := auth.uid();\r\n  _caller_role VARCHAR;\r\n  _plan_record record;\r\n  _is_member BOOLEAN;\r\n  _existing_user_plan_id UUID;\r\n  _new_user_plan_id UUID;\r\nBEGIN\r\n  -- 1. Check Authentication\r\n  IF _caller_id IS NULL THEN\r\n    RAISE EXCEPTION 'Authentication required to assign plans.';\r\n  END IF;\r\n\r\n  -- 2. Check Caller's Permissions (Must be coach/assistant in the specified team)\r\n  SELECT role INTO _caller_role\r\n  FROM public.team_members\r\n  WHERE user_id = _caller_id AND team_id = _team_id_context;\r\n\r\n  IF NOT FOUND OR _caller_role NOT IN ('coach', 'assistant_coach') THEN\r\n    RAISE EXCEPTION 'Caller lacks permission (must be coach or assistant coach in team %) to assign plans.', _team_id_context;\r\n  END IF;\r\n\r\n  -- 3. Validate Target User Membership\r\n  SELECT true INTO _is_member\r\n  FROM public.team_members\r\n  WHERE user_id = _user_id_to_assign AND team_id = _team_id_context;\r\n\r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'Target user % is not a member of team %.', _user_id_to_assign, _team_id_context;\r\n  END IF;\r\n\r\n  -- 4. Validate Plan Existence and Team Association\r\n  SELECT * INTO _plan_record\r\n  FROM public.plans\r\n  WHERE id = _plan_id_to_assign;\r\n\r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'Plan % not found.', _plan_id_to_assign;\r\n  END IF;\r\n\r\n  -- Enforce that the plan belongs to the team for team assignments\r\n  -- You could relax this check if coaches should be able to assign public plans too\r\n  IF _plan_record.team_id IS DISTINCT FROM _team_id_context THEN\r\n     RAISE EXCEPTION 'Plan % does not belong to team %.', _plan_id_to_assign, _team_id_context;\r\n     -- OR if coaches can assign public plans:\r\n     -- IF _plan_record.visibility <> 'public' AND _plan_record.team_id IS DISTINCT FROM _team_id_context THEN\r\n     --    RAISE EXCEPTION 'Plan % cannot be assigned in team context % (not public or team-owned).', _plan_id_to_assign, _team_id_context;\r\n     -- END IF;\r\n  END IF;\r\n\r\n  -- 5. Check for Existing ACTIVE Assignment\r\n  SELECT id INTO _existing_user_plan_id\r\n  FROM public.user_plans\r\n  WHERE user_id = _user_id_to_assign\r\n    AND plan_id = _plan_id_to_assign\r\n    AND status = 'active';\r\n\r\n  IF _existing_user_plan_id IS NOT NULL THEN\r\n    RAISE EXCEPTION 'User % already has an active assignment for plan %.', _user_id_to_assign, _plan_id_to_assign;\r\n    -- Alternatively, you could choose to update the existing record or return its ID.\r\n    -- RETURN _existing_user_plan_id;\r\n  END IF;\r\n\r\n  -- 6. Create the User Plan Assignment\r\n  INSERT INTO public.user_plans (\r\n      user_id,\r\n      plan_id,\r\n      start_date,\r\n      status,\r\n      privacy_level\r\n      -- end_date is NULL by default\r\n  ) VALUES (\r\n      _user_id_to_assign,\r\n      _plan_id_to_assign,\r\n      _start_date,\r\n      'active', -- Set status explicitly to active\r\n      _privacy_level -- Use provided privacy or default ('team')\r\n  )\r\n  RETURNING id INTO _new_user_plan_id;\r\n\r\n  -- 7. Return the new user_plans ID\r\n  RETURN _new_user_plan_id;\r\n\r\nEXCEPTION\r\n  WHEN others THEN\r\n    RAISE WARNING '[assign_team_plan_to_member] Error: %', SQLERRM;\r\n    RAISE; -- Re-raise the exception\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_discoverable_users",
    "definition": "CREATE OR REPLACE FUNCTION public.get_discoverable_users(p_role_filter text DEFAULT NULL::text, p_search_term text DEFAULT NULL::text, p_exclude_team_id uuid DEFAULT NULL::uuid, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\r\nSELECT\r\n    jsonb_agg(u_agg)\r\nFROM (\r\n    SELECT\r\n        p.*,\r\n        (\r\n            SELECT jsonb_agg(DISTINCT tm.role)\r\n            FROM team_members tm\r\n            WHERE tm.user_id = p.id\r\n        ) AS roles\r\n    FROM\r\n        profiles p\r\n    WHERE\r\n        -- The user must be in at least one public team to be \"discoverable\"\r\n        EXISTS (\r\n            SELECT 1\r\n            FROM team_members tm\r\n            JOIN teams t ON tm.team_id = t.id\r\n            WHERE tm.user_id = p.id AND t.is_private = false\r\n        )\r\n        -- ** THIS IS THE NEW PART **\r\n        -- If a team ID is provided for exclusion, the user must NOT be a member of that team.\r\n        AND (\r\n            p_exclude_team_id IS NULL OR\r\n            NOT EXISTS (\r\n                SELECT 1\r\n                FROM team_members tm\r\n                WHERE tm.user_id = p.id AND tm.team_id = p_exclude_team_id\r\n            )\r\n        )\r\n        -- Existing filters for role and search term\r\n        AND (\r\n            p_role_filter IS NULL OR\r\n            EXISTS (\r\n                SELECT 1\r\n                FROM team_members tm\r\n                WHERE tm.user_id = p.id AND tm.role::TEXT = p_role_filter\r\n            )\r\n        )\r\n        AND (\r\n            p_search_term IS NULL OR\r\n            p.full_name ILIKE ('%' || p_search_term || '%') OR\r\n            p.username ILIKE ('%' || p_search_term || '%')\r\n        )\r\n    ORDER BY\r\n        p.full_name\r\n    LIMIT p_page_limit\r\n    OFFSET p_page_offset\r\n) AS u_agg;\r\n$function$\n"
  }
]