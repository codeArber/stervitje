[
  {
    "schema_name": "public",
    "function_name": "add_exercise_set",
    "arguments": "p_set_data jsonb",
    "return_type": "plan_session_exercise_sets",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    new_set public.plan_session_exercise_sets;\r\n    -- Declare all necessary variables at the beginning\r\n    v_plan_session_exercise_id UUID := (p_set_data->>'p_plan_session_exercise_id')::uuid;\r\n    v_plan_session_id UUID;\r\n    v_plan_day_id UUID;\r\n    v_plan_week_id UUID;\r\n    v_plan_id UUID;\r\n    v_plan_owner_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    v_user_role public.team_member_role;\r\n    v_plan_team_id UUID;\r\nBEGIN\r\n    -- Get plan_id from exercise, and plan owner/team for permission checks\r\n    SELECT pse.plan_session_id, ps.plan_day_id, pd.plan_week_id, pw.plan_id, p.created_by, p.team_id\r\n    INTO v_plan_session_id, v_plan_day_id, v_plan_week_id, v_plan_id, v_plan_owner_id, v_plan_team_id\r\n    FROM public.plan_session_exercises pse\r\n    JOIN public.plan_sessions ps ON pse.plan_session_id = ps.id\r\n    JOIN public.plan_days pd ON ps.plan_day_id = pd.id\r\n    JOIN public.plan_weeks pw ON pd.plan_week_id = pw.id\r\n    JOIN public.plans p ON pw.plan_id = p.id\r\n    WHERE pse.id = v_plan_session_exercise_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Plan Session Exercise with ID % not found.', v_plan_session_exercise_id;\r\n    END IF;\r\n\r\n    -- Permission check: Must be the plan creator OR an admin/coach in the plan's team\r\n    IF v_plan_owner_id IS DISTINCT FROM v_user_id THEN\r\n        IF v_plan_team_id IS NOT NULL THEN\r\n            SELECT role INTO v_user_role FROM public.team_members\r\n            WHERE user_id = v_user_id AND team_id = v_plan_team_id;\r\n\r\n            IF v_user_role IS NULL OR v_user_role NOT IN ('admin', 'coach') THEN\r\n                RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n            END IF;\r\n        ELSE\r\n            RAISE EXCEPTION 'Permission denied: Not plan creator.';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Optional: Ensure set_number is unique within the exercise\r\n    IF EXISTS (SELECT 1 FROM public.plan_session_exercise_sets WHERE plan_session_exercise_id = v_plan_session_exercise_id AND set_number = (p_set_data->>'p_set_number')::smallint) THEN\r\n        RAISE EXCEPTION 'A set with number % already exists for this exercise.', (p_set_data->>'p_set_number')::smallint;\r\n    END IF;\r\n\r\n    INSERT INTO public.plan_session_exercise_sets (\r\n        plan_session_exercise_id,\r\n        set_number,\r\n        target_reps,\r\n        target_weight,\r\n        target_duration_seconds,\r\n        target_distance_meters,\r\n        target_rest_seconds,\r\n        notes,\r\n        set_type,\r\n        metadata\r\n    )\r\n    VALUES (\r\n        v_plan_session_exercise_id,\r\n        (p_set_data->>'p_set_number')::smallint,\r\n        (p_set_data->>'p_target_reps')::smallint,\r\n        (p_set_data->>'p_target_weight')::numeric,\r\n        (p_set_data->>'p_target_duration_seconds')::integer,\r\n        (p_set_data->>'p_target_distance_meters')::numeric,\r\n        (p_set_data->>'p_target_rest_seconds')::integer,\r\n        (p_set_data->>'p_notes')::text,\r\n        (p_set_data->>'p_set_type')::public.set_type,\r\n        (p_set_data->'p_metadata')::jsonb -- Cast to jsonb\r\n    )\r\n    RETURNING * INTO new_set;\r\n\r\n    RETURN new_set;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "add_plan_day",
    "arguments": "p_plan_week_id uuid, p_day_number smallint, p_title character varying DEFAULT NULL::character varying, p_description text DEFAULT NULL::text, p_is_rest_day boolean DEFAULT false",
    "return_type": "plan_days",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    new_day public.plan_days;\r\n    v_plan_id UUID;\r\n    v_plan_owner_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    v_user_role public.team_member_role;\r\n    v_plan_team_id UUID;\r\nBEGIN\r\n    -- Get plan_id from week, and plan owner/team_id for permission checks\r\n    SELECT pw.plan_id, p.created_by, p.team_id\r\n    INTO v_plan_id, v_plan_owner_id, v_plan_team_id\r\n    FROM public.plan_weeks pw\r\n    JOIN public.plans p ON pw.plan_id = p.id\r\n    WHERE pw.id = p_plan_week_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Plan Week with ID % not found.', p_plan_week_id;\r\n    END IF;\r\n\r\n    -- Permission check: Must be the plan creator OR an admin/coach in the plan's team\r\n    IF v_plan_owner_id IS DISTINCT FROM v_user_id THEN\r\n        IF v_plan_team_id IS NOT NULL THEN\r\n            SELECT role INTO v_user_role FROM public.team_members\r\n            WHERE user_id = v_user_id AND team_id = v_plan_team_id;\r\n\r\n            IF v_user_role IS NULL OR v_user_role NOT IN ('admin', 'coach') THEN\r\n                RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n            END IF;\r\n        ELSE\r\n            RAISE EXCEPTION 'Permission denied: Not plan creator.';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Optional: Ensure day_number is unique within the week (if desired)\r\n    IF EXISTS (SELECT 1 FROM public.plan_days WHERE plan_week_id = p_plan_week_id AND day_number = p_day_number) THEN\r\n        RAISE EXCEPTION 'A day with number % already exists for this week.', p_day_number;\r\n    END IF;\r\n\r\n    INSERT INTO public.plan_days (\r\n        plan_week_id,\r\n        day_number,\r\n        title,\r\n        description,\r\n        is_rest_day\r\n    )\r\n    VALUES (\r\n        p_plan_week_id,\r\n        p_day_number,\r\n        p_title,\r\n        p_description,\r\n        p_is_rest_day\r\n    )\r\n    RETURNING * INTO new_day;\r\n\r\n    RETURN new_day;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "add_plan_goal",
    "arguments": "p_plan_id uuid, p_title text, p_metric goal_metric, p_direction goal_direction, p_target_type goal_target_type, p_target_value numeric, p_description text DEFAULT NULL::text, p_exercise_id uuid DEFAULT NULL::uuid",
    "return_type": "plan_goals",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n  new_goal public.plan_goals;\r\nBEGIN\r\n  -- Security Check: Ensure the user can edit the plan\r\n  IF NOT public.user_can_edit_plan(p_plan_id) THEN\r\n      RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n  END IF;\r\n\r\n  INSERT INTO public.plan_goals (\r\n    plan_id,\r\n    title,\r\n    description,\r\n    metric,\r\n    direction,\r\n    target_type,\r\n    target_value,\r\n    exercise_id\r\n  )\r\n  VALUES (\r\n    p_plan_id,\r\n    p_title,\r\n    p_description,\r\n    p_metric,\r\n    p_direction,\r\n    p_target_type,\r\n    p_target_value,\r\n    p_exercise_id\r\n  )\r\n  RETURNING * INTO new_goal;\r\n\r\n  RETURN new_goal;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "add_plan_session",
    "arguments": "p_plan_day_id uuid, p_order_index smallint, p_title character varying DEFAULT NULL::character varying, p_notes text DEFAULT NULL::text",
    "return_type": "plan_sessions",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    new_session public.plan_sessions;\r\n    v_plan_day_id UUID; -- <--- CORRECTED: Declared here\r\n    v_plan_week_id UUID; -- <--- CORRECTED: Declared here\r\n    v_plan_id UUID;\r\n    v_plan_owner_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    v_user_role public.team_member_role;\r\n    v_plan_team_id UUID;\r\nBEGIN\r\n    -- Get plan_id from day, and plan owner/team_id for permission checks\r\n    SELECT pd.plan_week_id, pw.plan_id, p.created_by, p.team_id\r\n    INTO v_plan_week_id, v_plan_id, v_plan_owner_id, v_plan_team_id -- <--- Corrected variable usage\r\n    FROM public.plan_days pd\r\n    JOIN public.plan_weeks pw ON pd.plan_week_id = pw.id\r\n    JOIN public.plans p ON pw.plan_id = p.id\r\n    WHERE pd.id = p_plan_day_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Plan Day with ID % not found.', p_plan_day_id;\r\n    END IF;\r\n\r\n    -- Permission check: Must be the plan creator OR an admin/coach in the plan's team\r\n    IF v_plan_owner_id IS DISTINCT FROM v_user_id THEN\r\n        IF v_plan_team_id IS NOT NULL THEN\r\n            SELECT role INTO v_user_role FROM public.team_members\r\n            WHERE user_id = v_user_id AND team_id = v_plan_team_id;\r\n\r\n            IF v_user_role IS NULL OR v_user_role NOT IN ('admin', 'coach') THEN\r\n                RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n            END IF;\r\n        ELSE\r\n            RAISE EXCEPTION 'Permission denied: Not plan creator.';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Optional: Ensure order_index is unique within the day (if desired)\r\n    IF EXISTS (SELECT 1 FROM public.plan_sessions WHERE plan_day_id = p_plan_day_id AND order_index = p_order_index) THEN\r\n        RAISE EXCEPTION 'A session with order index % already exists for this day.', p_order_index;\r\n    END IF;\r\n\r\n    INSERT INTO public.plan_sessions (\r\n        plan_day_id,\r\n        order_index,\r\n        title,\r\n        notes\r\n    )\r\n    VALUES (\r\n        p_plan_day_id,\r\n        p_order_index,\r\n        p_title,\r\n        p_notes\r\n    )\r\n    RETURNING * INTO new_session;\r\n\r\n    RETURN new_session;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "add_plan_session_exercise",
    "arguments": "p_plan_session_id uuid, p_exercise_id uuid, p_order_within_session smallint, p_notes text DEFAULT NULL::text, p_execution_group smallint DEFAULT 1, p_post_exercise_rest_seconds integer DEFAULT 0, p_post_group_rest_seconds integer DEFAULT 0",
    "return_type": "jsonb",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    new_exercise public.plan_session_exercises;\r\n    v_exercise_details public.exercises; -- To store joined exercise details\r\n    -- Declare all necessary variables at the beginning\r\n    v_plan_day_id UUID;\r\n    v_plan_week_id UUID;\r\n    v_plan_id UUID;\r\n    v_plan_owner_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    v_user_role public.team_member_role;\r\n    v_plan_team_id UUID;\r\nBEGIN\r\n    -- Get plan_id from session, and plan owner/team for permission checks\r\n    SELECT ps.plan_day_id, pd.plan_week_id, pw.plan_id, p.created_by, p.team_id\r\n    INTO v_plan_day_id, v_plan_week_id, v_plan_id, v_plan_owner_id, v_plan_team_id\r\n    FROM public.plan_sessions ps\r\n    JOIN public.plan_days pd ON ps.plan_day_id = pd.id\r\n    JOIN public.plan_weeks pw ON pd.plan_week_id = pw.id\r\n    JOIN public.plans p ON pw.plan_id = p.id\r\n    WHERE ps.id = p_plan_session_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Plan Session with ID % not found.', p_plan_session_id;\r\n    END IF;\r\n\r\n    -- Permission check: Must be the plan creator OR an admin/coach in the plan's team\r\n    IF v_plan_owner_id IS DISTINCT FROM v_user_id THEN\r\n        IF v_plan_team_id IS NOT NULL THEN\r\n            SELECT role INTO v_user_role FROM public.team_members\r\n            WHERE user_id = v_user_id AND team_id = v_plan_team_id;\r\n\r\n            IF v_user_role IS NULL OR v_user_role NOT IN ('admin', 'coach') THEN\r\n                RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n            END IF;\r\n        ELSE\r\n            RAISE EXCEPTION 'Permission denied: Not plan creator.';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Optional: Ensure order_within_session is unique within the session\r\n    IF EXISTS (SELECT 1 FROM public.plan_session_exercises WHERE plan_session_id = p_plan_session_id AND order_within_session = p_order_within_session) THEN\r\n        RAISE EXCEPTION 'An exercise with order index % already exists for this session.', p_order_within_session;\r\n    END IF;\r\n\r\n    -- Insert the new exercise\r\n    INSERT INTO public.plan_session_exercises (\r\n        plan_session_id,\r\n        exercise_id,\r\n        order_within_session,\r\n        notes,\r\n        execution_group,\r\n        post_exercise_rest_seconds,\r\n        post_group_rest_seconds\r\n    )\r\n    VALUES (\r\n        p_plan_session_id,\r\n        p_exercise_id,\r\n        p_order_within_session,\r\n        p_notes,\r\n        p_execution_group,\r\n        p_post_exercise_rest_seconds,\r\n        p_post_group_rest_seconds\r\n    )\r\n    RETURNING * INTO new_exercise;\r\n\r\n    -- Fetch the full exercise details\r\n    SELECT * INTO v_exercise_details\r\n    FROM public.exercises\r\n    WHERE id = new_exercise.exercise_id;\r\n\r\n    -- Return the combined JSONB object\r\n    RETURN jsonb_build_object(\r\n        'id', new_exercise.id,\r\n        'plan_session_id', new_exercise.plan_session_id,\r\n        'exercise_id', new_exercise.exercise_id,\r\n        'order_within_session', new_exercise.order_within_session,\r\n        'notes', new_exercise.notes,\r\n        'execution_group', new_exercise.execution_group,\r\n        'post_exercise_rest_seconds', new_exercise.post_exercise_rest_seconds,\r\n        'post_group_rest_seconds', new_exercise.post_group_rest_seconds,\r\n        'created_at', new_exercise.created_at,\r\n        'updated_at', new_exercise.updated_at,\r\n        'exercise_details', to_jsonb(v_exercise_details),\r\n        'sets', '[]'::jsonb -- Initialize with an empty sets array for consistency with PlanExercise type\r\n    );\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "add_plan_week",
    "arguments": "p_plan_id uuid, p_week_number smallint, p_description text DEFAULT NULL::text",
    "return_type": "plan_weeks",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    new_week public.plan_weeks;\r\n    v_plan_owner_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    v_user_role public.team_member_role;\r\n    v_plan_team_id UUID;\r\nBEGIN\r\n    -- Get plan owner and team_id for permission checks\r\n    SELECT created_by, team_id INTO v_plan_owner_id, v_plan_team_id\r\n    FROM public.plans\r\n    WHERE id = p_plan_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Plan with ID % not found.', p_plan_id;\r\n    END IF;\r\n\r\n    -- Permission check: Must be the plan creator OR an admin/coach in the plan's team\r\n    IF v_plan_owner_id IS DISTINCT FROM v_user_id THEN\r\n        IF v_plan_team_id IS NOT NULL THEN\r\n            SELECT role INTO v_user_role FROM public.team_members\r\n            WHERE user_id = v_user_id AND team_id = v_plan_team_id;\r\n\r\n            IF v_user_role IS NULL OR v_user_role NOT IN ('admin', 'coach') THEN\r\n                RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n            END IF;\r\n        ELSE\r\n            -- If plan has no team and user is not owner, deny\r\n            RAISE EXCEPTION 'Permission denied: Not plan creator.';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Ensure week_number is unique within the plan (optional, but good practice)\r\n    IF EXISTS (SELECT 1 FROM public.plan_weeks WHERE plan_id = p_plan_id AND week_number = p_week_number) THEN\r\n        RAISE EXCEPTION 'A week with number % already exists for this plan.', p_week_number;\r\n    END IF;\r\n\r\n    INSERT INTO public.plan_weeks (\r\n        plan_id,\r\n        week_number,\r\n        description\r\n    )\r\n    VALUES (\r\n        p_plan_id,\r\n        p_week_number,\r\n        p_description\r\n    )\r\n    RETURNING * INTO new_week;\r\n\r\n    RETURN new_week;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "assign_team_plan_to_member",
    "arguments": "_user_id_to_assign uuid, _plan_id_to_assign uuid, _team_id_context uuid, _start_date date DEFAULT now(), _privacy_level character varying DEFAULT 'team'::character varying",
    "return_type": "uuid",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n  _caller_id uuid := auth.uid();\r\n  _caller_role VARCHAR;\r\n  _plan_record public.plans; -- Changed to specific type for clarity\r\n  _is_member BOOLEAN;\r\n  _existing_user_plan_status_id UUID; -- Updated variable name\r\n  _new_user_plan_status_id UUID;     -- Updated variable name\r\nBEGIN\r\n  -- 1. Check Authentication\r\n  IF _caller_id IS NULL THEN\r\n    RAISE EXCEPTION 'Authentication required to assign plans.';\r\n  END IF;\r\n\r\n  -- 2. Check Caller's Permissions (Must be coach/assistant in the specified team)\r\n  SELECT role INTO _caller_role\r\n  FROM public.team_members\r\n  WHERE user_id = _caller_id AND team_id = _team_id_context;\r\n\r\n  IF NOT FOUND OR _caller_role NOT IN ('coach', 'assistant_coach') THEN\r\n    RAISE EXCEPTION 'Caller lacks permission (must be coach or assistant coach in team %) to assign plans.', _team_id_context;\r\n  END IF;\r\n\r\n  -- 3. Validate Target User Membership\r\n  SELECT true INTO _is_member\r\n  FROM public.team_members\r\n  WHERE user_id = _user_id_to_assign AND team_id = _team_id_context;\r\n\r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'Target user % is not a member of team %.', _user_id_to_assign, _team_id_context;\r\n  END IF;\r\n\r\n  -- 4. Validate Plan Existence and Team Association\r\n  SELECT * INTO _plan_record\r\n  FROM public.plans\r\n  WHERE id = _plan_id_to_assign;\r\n\r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'Plan % not found.', _plan_id_to_assign;\r\n  END IF;\r\n\r\n  -- Enforce that the plan belongs to the team for team assignments\r\n  IF _plan_record.team_id IS DISTINCT FROM _team_id_context THEN\r\n     RAISE EXCEPTION 'Plan % does not belong to team %.', _plan_id_to_assign, _team_id_context;\r\n  END IF;\r\n\r\n  -- 5. Check for Existing ACTIVE Assignment in user_plan_status\r\n  SELECT id INTO _existing_user_plan_status_id\r\n  FROM public.user_plan_status -- Corrected table name\r\n  WHERE user_id = _user_id_to_assign\r\n    AND plan_id = _plan_id_to_assign\r\n    AND status = 'active';\r\n\r\n  IF _existing_user_plan_status_id IS NOT NULL THEN\r\n    RAISE EXCEPTION 'User % already has an active assignment for plan %.', _user_id_to_assign, _plan_id_to_assign;\r\n  END IF;\r\n\r\n  -- 6. Create the User Plan Assignment in user_plan_status\r\n  INSERT INTO public.user_plan_status ( -- Corrected table name\r\n      user_id,\r\n      plan_id,\r\n      started_at, -- Use 'started_at' for initial date, 'last_activity_at' will be updated by trigger\r\n      status\r\n      -- privacy_level is not in user_plan_status, it's a session_logs field\r\n  ) VALUES (\r\n      _user_id_to_assign,\r\n      _plan_id_to_assign,\r\n      _start_date,\r\n      'active'\r\n  )\r\n  RETURNING id INTO _new_user_plan_status_id;\r\n\r\n  -- 7. Return the new user_plan_status ID\r\n  RETURN _new_user_plan_status_id;\r\n\r\nEXCEPTION\r\n  WHEN others THEN\r\n    RAISE WARNING '[assign_team_plan_to_member] Error: %', SQLERRM;\r\n    RAISE; -- Re-raise the exception\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "claim_pending_invitations",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nBEGIN\r\n  -- This function runs AFTER a new user's profile is created.\r\n  -- The 'NEW' variable holds the data for the new profile row.\r\n\r\n  -- Look for any pending invitations that match the new user's email\r\n  -- and update them with the new user's ID.\r\n  UPDATE public.team_invitations\r\n  SET invited_user_id = NEW.id\r\n  WHERE invited_email = NEW.email AND status = 'pending';\r\n\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "complete_onboarding",
    "arguments": "",
    "return_type": "void",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n    -- Find the profile record for the currently authenticated user\r\n    -- and update the onboarding_completed flag to TRUE.\r\n    UPDATE public.profiles\r\n    SET onboarding_completed = true\r\n    WHERE id = auth.uid();\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "create_basic_plan",
    "arguments": "p_title character varying, p_description text DEFAULT NULL::text, p_difficulty_level smallint DEFAULT NULL::smallint, p_private boolean DEFAULT false, p_team_id uuid DEFAULT NULL::uuid",
    "return_type": "plans",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    new_plan public.plans;\r\n    v_created_by uuid := auth.uid();\r\n    v_is_team_member BOOLEAN := FALSE;\r\nBEGIN\r\n    -- Basic validation\r\n    IF p_title IS NULL OR p_title = '' THEN\r\n        RAISE EXCEPTION 'Plan title cannot be empty.';\r\n    END IF;\r\n\r\n    -- If a team_id is provided, ensure the creator is a member of that team\r\n    IF p_team_id IS NOT NULL THEN\r\n        SELECT EXISTS (\r\n            SELECT 1 FROM public.team_members\r\n            WHERE user_id = v_created_by AND team_id = p_team_id\r\n        ) INTO v_is_team_member;\r\n\r\n        IF NOT v_is_team_member THEN\r\n            RAISE EXCEPTION 'Permission denied: User is not a member of the specified team.';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Insert the new plan record\r\n    INSERT INTO public.plans (\r\n        title,\r\n        description,\r\n        difficulty_level,\r\n        private,\r\n        created_by,\r\n        team_id,\r\n        allow_public_forking -- Defaults to FALSE from table schema\r\n    )\r\n    VALUES (\r\n        p_title,\r\n        p_description,\r\n        p_difficulty_level,\r\n        p_private,\r\n        v_created_by,\r\n        p_team_id,\r\n        FALSE -- Explicitly set default, or let table default\r\n    )\r\n    RETURNING * INTO new_plan;\r\n\r\n    RETURN new_plan;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "create_new_team",
    "arguments": "p_name text, p_description text DEFAULT NULL::text, p_sport text DEFAULT NULL::text, p_is_private boolean DEFAULT false",
    "return_type": "teams",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    v_user_id UUID := auth.uid();\r\n    new_team teams;\r\nBEGIN\r\n    -- Step 1: Create the new team record.\r\n    -- The 'is_personal_workspace' flag defaults to FALSE, so this is a collaborative team.\r\n    INSERT INTO public.teams (name, description, sport, is_private, created_by)\r\n    VALUES (p_name, p_description, p_sport, p_is_private, v_user_id)\r\n    RETURNING * INTO new_team;\r\n\r\n    -- Step 2: Make the creator of the team an 'admin'.\r\n    -- This insert is also covered by the SECURITY DEFINER nature of the function.\r\n    INSERT INTO public.team_members (team_id, user_id, role)\r\n    VALUES (new_team.id, v_user_id, 'admin');\r\n\r\n    -- Step 3: Return the newly created team record.\r\n    RETURN NEXT new_team;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "delete_plan_day",
    "arguments": "p_day_id uuid",
    "return_type": "void",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    v_plan_id UUID;\r\n    v_plan_owner_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    v_user_role public.team_member_role;\r\n    v_plan_team_id UUID;\r\n    v_plan_week_id UUID; -- <--- CORRECTED: Declared here\r\nBEGIN\r\n    -- Get plan_id from day, and plan owner/team for permission checks\r\n    SELECT pd.plan_week_id, pw.plan_id, p.created_by, p.team_id\r\n    INTO v_plan_week_id, v_plan_id, v_plan_owner_id, v_plan_team_id\r\n    FROM public.plan_days pd\r\n    JOIN public.plan_weeks pw ON pd.plan_week_id = pw.id\r\n    JOIN public.plans p ON pw.plan_id = p.id\r\n    WHERE pd.id = p_day_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Day with ID % not found.', p_day_id;\r\n    END IF;\r\n\r\n    -- Permission check: Must be the plan creator OR an admin/coach in the plan's team\r\n    IF v_plan_owner_id IS DISTINCT FROM v_user_id THEN\r\n        IF v_plan_team_id IS NOT NULL THEN\r\n            SELECT role INTO v_user_role FROM public.team_members\r\n            WHERE user_id = v_user_id AND team_id = v_plan_team_id;\r\n\r\n            IF v_user_role IS NULL OR v_user_role NOT IN ('admin', 'coach') THEN\r\n                RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n            END IF;\r\n        ELSE\r\n            RAISE EXCEPTION 'Permission denied: Not plan creator.';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Delete the day. ON DELETE CASCADE foreign key constraints should handle\r\n    -- deleting associated plan_sessions, plan_session_exercises, and plan_session_exercise_sets.\r\n    DELETE FROM public.plan_days\r\n    WHERE id = p_day_id;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "delete_plan_goal",
    "arguments": "p_goal_id uuid",
    "return_type": "void",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n  v_plan_id UUID;\r\nBEGIN\r\n  -- Get the plan_id associated with the goal\r\n  SELECT plan_id INTO v_plan_id FROM public.plan_goals WHERE id = p_goal_id;\r\n\r\n  IF NOT FOUND THEN\r\n      RAISE EXCEPTION 'Plan Goal with ID % not found.', p_goal_id;\r\n  END IF;\r\n\r\n  -- Security Check: Ensure the user can edit the plan\r\n  IF NOT public.user_can_edit_plan(v_plan_id) THEN\r\n      RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n  END IF;\r\n\r\n  DELETE FROM public.plan_goals\r\n  WHERE id = p_goal_id;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "delete_plan_session",
    "arguments": "p_session_id uuid",
    "return_type": "void",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    -- CORRECTED: Declare all variables at the beginning\r\n    v_plan_day_id UUID;\r\n    v_plan_week_id UUID;\r\n    v_plan_id UUID;\r\n    v_plan_owner_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    v_user_role public.team_member_role;\r\n    v_plan_team_id UUID;\r\nBEGIN\r\n    -- Get plan_id from session, and plan owner/team for permission checks\r\n    SELECT ps.plan_day_id, pd.plan_week_id, pw.plan_id, p.created_by, p.team_id\r\n    INTO v_plan_day_id, v_plan_week_id, v_plan_id, v_plan_owner_id, v_plan_team_id\r\n    FROM public.plan_sessions ps\r\n    JOIN public.plan_days pd ON ps.plan_day_id = pd.id\r\n    JOIN public.plan_weeks pw ON pd.plan_week_id = pw.id\r\n    JOIN public.plans p ON pw.plan_id = p.id\r\n    WHERE ps.id = p_session_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Plan Session with ID % not found.', p_session_id;\r\n    END IF;\r\n\r\n    -- Permission check: Must be the plan creator OR an admin/coach in the plan's team\r\n    IF v_plan_owner_id IS DISTINCT FROM v_user_id THEN\r\n        IF v_plan_team_id IS NOT NULL THEN\r\n            SELECT role INTO v_user_role FROM public.team_members\r\n            WHERE user_id = v_user_id AND team_id = v_plan_team_id;\r\n\r\n            IF v_user_role IS NULL OR v_user_role NOT IN ('admin', 'coach') THEN\r\n                RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n            END IF;\r\n        ELSE\r\n            RAISE EXCEPTION 'Permission denied: Not plan creator.';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Delete the session. ON DELETE CASCADE foreign key constraints should handle\r\n    -- deleting associated plan_session_exercises and plan_session_exercise_sets.\r\n    DELETE FROM public.plan_sessions\r\n    WHERE id = p_session_id;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "delete_plan_week",
    "arguments": "p_week_id uuid",
    "return_type": "void",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    v_plan_id UUID;\r\n    v_plan_owner_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    v_user_role public.team_member_role;\r\n    v_plan_team_id UUID;\r\nBEGIN\r\n    -- Get plan_id from week, and plan owner/team for permission checks\r\n    SELECT pw.plan_id, p.created_by, p.team_id\r\n    INTO v_plan_id, v_plan_owner_id, v_plan_team_id\r\n    FROM public.plan_weeks pw\r\n    JOIN public.plans p ON pw.plan_id = p.id\r\n    WHERE pw.id = p_week_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Week with ID % not found.', p_week_id;\r\n    END IF;\r\n\r\n    -- Permission check: Must be the plan creator OR an admin/coach in the plan's team\r\n    IF v_plan_owner_id IS DISTINCT FROM v_user_id THEN\r\n        IF v_plan_team_id IS NOT NULL THEN\r\n            SELECT role INTO v_user_role FROM public.team_members\r\n            WHERE user_id = v_user_id AND team_id = v_plan_team_id;\r\n\r\n            IF v_user_role IS NULL OR v_user_role NOT IN ('admin', 'coach') THEN\r\n                RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n            END IF;\r\n        ELSE\r\n            RAISE EXCEPTION 'Permission denied: Not plan creator.';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Delete the week. ON DELETE CASCADE foreign key constraints should handle\r\n    -- deleting associated plan_days, plan_sessions, plan_session_exercises, and plan_session_exercise_sets.\r\n    DELETE FROM public.plan_weeks\r\n    WHERE id = p_week_id;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "fork_plan",
    "arguments": "p_original_plan_id uuid",
    "return_type": "uuid",
    "language": "plpgsql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nDECLARE\r\n    _caller_id uuid := auth.uid();\r\n    _original_plan record;\r\n    _new_plan_id uuid;\r\n    week_record record;\r\n    day_record record;\r\n    session_record record;\r\n    exercise_record record;\r\n    _new_week_id uuid;\r\n    _new_day_id uuid;\r\n    _new_session_id uuid;\r\n    _new_exercise_id uuid;\r\nBEGIN\r\n    -- Validate access and fetch original plan\r\n    SELECT * INTO _original_plan FROM public.plans WHERE id = p_original_plan_id;\r\n    IF NOT FOUND THEN RAISE EXCEPTION 'Original plan not found'; END IF;\r\n    IF _original_plan.private = true AND _original_plan.created_by <> _caller_id AND NOT _original_plan.allow_public_forking THEN RAISE EXCEPTION 'Permission denied: This plan cannot be forked'; END IF;\r\n\r\n    -- 1. Create the new forked plan record\r\n    INSERT INTO public.plans (title, description, difficulty_level, created_by, private, forked_from, allow_public_forking)\r\n    VALUES ('Fork of ' || _original_plan.title, _original_plan.description, _original_plan.difficulty_level, _caller_id, true, p_original_plan_id, false)\r\n    RETURNING id INTO _new_plan_id;\r\n\r\n    -- 2. Copy all plan goals\r\n    INSERT INTO public.plan_goals (plan_id, title, description, metric, target_value, exercise_id)\r\n    SELECT _new_plan_id, title, description, metric, target_value, exercise_id\r\n    FROM public.plan_goals WHERE plan_id = p_original_plan_id;\r\n\r\n    -- 3. Loop through and deep copy the hierarchy\r\n    FOR week_record IN SELECT * FROM public.plan_weeks WHERE plan_id = p_original_plan_id ORDER BY week_number LOOP\r\n        INSERT INTO public.plan_weeks (plan_id, week_number, description)\r\n        VALUES (_new_plan_id, week_record.week_number, week_record.description)\r\n        RETURNING id INTO _new_week_id;\r\n\r\n        FOR day_record IN SELECT * FROM public.plan_days WHERE plan_week_id = week_record.id ORDER BY day_number LOOP\r\n            INSERT INTO public.plan_days (plan_week_id, day_number, title, description, is_rest_day)\r\n            VALUES (_new_week_id, day_record.day_number, day_record.title, day_record.description, day_record.is_rest_day)\r\n            RETURNING id INTO _new_day_id;\r\n\r\n            FOR session_record IN SELECT * FROM public.plan_sessions WHERE plan_day_id = day_record.id ORDER BY order_index LOOP\r\n                INSERT INTO public.plan_sessions (plan_day_id, order_index, title, notes)\r\n                VALUES (_new_day_id, session_record.order_index, session_record.title, session_record.notes)\r\n                RETURNING id INTO _new_session_id;\r\n\r\n                FOR exercise_record IN SELECT * FROM public.plan_session_exercises WHERE plan_session_id = session_record.id ORDER BY order_within_session LOOP\r\n                    INSERT INTO public.plan_session_exercises (plan_session_id, exercise_id, order_within_session, notes, execution_group, post_exercise_rest_seconds, post_group_rest_seconds)\r\n                    VALUES (_new_session_id, exercise_record.exercise_id, exercise_record.order_within_session, exercise_record.notes, exercise_record.execution_group, exercise_record.post_exercise_rest_seconds, exercise_record.post_group_rest_seconds)\r\n                    RETURNING id INTO _new_exercise_id;\r\n\r\n                    -- Copy all sets for the exercise\r\n                    INSERT INTO public.plan_session_exercise_sets (plan_session_exercise_id, set_number, target_reps, target_weight, target_duration_seconds, target_distance_meters, notes, set_type, metadata)\r\n                    SELECT _new_exercise_id, set_number, target_reps, target_weight, target_duration_seconds, target_distance_meters, notes, set_type, metadata\r\n                    FROM public.plan_session_exercise_sets WHERE plan_session_exercise_id = exercise_record.id;\r\n                END LOOP;\r\n            END LOOP;\r\n        END LOOP;\r\n    END LOOP;\r\n\r\n    -- 4. Increment the fork count on the original plan\r\n    UPDATE public.plans SET fork_count = fork_count + 1 WHERE id = p_original_plan_id;\r\n\r\n    RETURN _new_plan_id;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_active_session_for_user",
    "arguments": "",
    "return_type": "session_logs",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n  SELECT *\r\n  FROM public.session_logs\r\n  WHERE user_id = auth.uid() AND status = 'in_progress'\r\n  LIMIT 1;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_client_progress_for_coach",
    "arguments": "p_client_id uuid",
    "return_type": "session_logs",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n    SELECT sl.*\r\n    FROM session_logs sl\r\n    WHERE sl.user_id = p_client_id\r\n      -- SECURITY CHECK: This query will only return rows if the person calling the function...\r\n      AND EXISTS (\r\n        SELECT 1\r\n        FROM team_members caller_membership\r\n        JOIN team_members client_membership ON caller_membership.team_id = client_membership.team_id\r\n        WHERE\r\n            -- ...is a coach or admin in the same team as the client.\r\n            caller_membership.user_id = auth.uid()\r\n            AND client_membership.user_id = p_client_id\r\n            AND caller_membership.role IN ('admin', 'coach')\r\n      );\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_discoverable_teams_rich",
    "arguments": "p_search_term text DEFAULT NULL::text",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nSELECT\r\n    jsonb_agg(t_agg)\r\nFROM (\r\n    SELECT\r\n        t.*,\r\n        (SELECT COUNT(*) FROM team_members tm WHERE tm.team_id = t.id) AS members_count,\r\n        (SELECT COUNT(*) FROM plans p WHERE p.team_id = t.id) AS plans_count,\r\n        \r\n        -- NEW: Get the full profiles of admins and coaches\r\n        (\r\n            SELECT jsonb_agg(jsonb_build_object('profile', p, 'role', tm.role))\r\n            FROM team_members tm\r\n            JOIN profiles p ON tm.user_id = p.id\r\n            WHERE tm.team_id = t.id AND tm.role IN ('admin', 'coach')\r\n        ) AS key_members,\r\n\r\n        -- NEW: Get a preview of up to 15 member names for tooltips\r\n        (\r\n            SELECT jsonb_agg(p.full_name)\r\n            FROM (\r\n                SELECT p_inner.*\r\n                FROM team_members tm\r\n                JOIN profiles p_inner ON tm.user_id = p_inner.id\r\n                WHERE tm.team_id = t.id\r\n                ORDER BY tm.role, p_inner.full_name\r\n                LIMIT 15\r\n            ) p\r\n        ) AS member_names_preview\r\n\r\n    FROM\r\n        teams t\r\n    WHERE\r\n        t.is_private = false\r\n        AND (\r\n            p_search_term IS NULL OR\r\n            t.name ILIKE ('%' || p_search_term || '%') OR\r\n            t.description ILIKE ('%' || p_search_term || '%')\r\n        )\r\n    ORDER BY\r\n        t.created_at DESC\r\n) AS t_agg;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_discoverable_users",
    "arguments": "p_role_filter text DEFAULT NULL::text, p_search_term text DEFAULT NULL::text, p_exclude_team_id uuid DEFAULT NULL::uuid, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nSELECT\r\n    jsonb_agg(u_agg)\r\nFROM (\r\n    SELECT\r\n        p.*,\r\n        (\r\n            SELECT jsonb_agg(DISTINCT tm.role)\r\n            FROM team_members tm\r\n            WHERE tm.user_id = p.id\r\n        ) AS roles\r\n    FROM\r\n        profiles p\r\n    WHERE\r\n        -- The user must be in at least one public team to be \"discoverable\"\r\n        EXISTS (\r\n            SELECT 1\r\n            FROM team_members tm\r\n            JOIN teams t ON tm.team_id = t.id\r\n            WHERE tm.user_id = p.id AND t.is_private = false\r\n        )\r\n        -- ** THIS IS THE NEW PART **\r\n        -- If a team ID is provided for exclusion, the user must NOT be a member of that team.\r\n        AND (\r\n            p_exclude_team_id IS NULL OR\r\n            NOT EXISTS (\r\n                SELECT 1\r\n                FROM team_members tm\r\n                WHERE tm.user_id = p.id AND tm.team_id = p_exclude_team_id\r\n            )\r\n        )\r\n        -- Existing filters for role and search term\r\n        AND (\r\n            p_role_filter IS NULL OR\r\n            EXISTS (\r\n                SELECT 1\r\n                FROM team_members tm\r\n                WHERE tm.user_id = p.id AND tm.role::TEXT = p_role_filter\r\n            )\r\n        )\r\n        AND (\r\n            p_search_term IS NULL OR\r\n            p.full_name ILIKE ('%' || p_search_term || '%') OR\r\n            p.username ILIKE ('%' || p_search_term || '%')\r\n        )\r\n    ORDER BY\r\n        p.full_name\r\n    LIMIT p_page_limit\r\n    OFFSET p_page_offset\r\n) AS u_agg;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_exercise_details",
    "arguments": "p_exercise_id uuid",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n    SELECT\r\n        jsonb_build_object(\r\n            'exercise', to_jsonb(e),\r\n            'muscles', (\r\n                SELECT jsonb_agg(\r\n                    jsonb_build_object(\r\n                        'muscle', em.muscle_group,\r\n                        'engagement', em.engagement_level\r\n                    )\r\n                )\r\n                FROM exercise_muscle em\r\n                WHERE em.exercise_id = e.id\r\n            ),\r\n            'tags', (\r\n                SELECT jsonb_agg(t)\r\n                FROM exercise_tags et\r\n                JOIN tags t ON et.tag_id = t.id\r\n                WHERE et.exercise_id = e.id\r\n            ),\r\n            'references', (\r\n                 SELECT jsonb_agg(erg)\r\n                 FROM exercise_reference_global erg\r\n                 WHERE erg.exercise_id = e.id\r\n            )\r\n        )\r\n    FROM exercises e\r\n    WHERE e.id = p_exercise_id;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_filtered_exercises_with_details",
    "arguments": "p_search_term text DEFAULT NULL::text, p_muscle_groups text[] DEFAULT NULL::text[], p_tag_ids integer[] DEFAULT NULL::integer[], p_difficulty_level integer DEFAULT NULL::integer, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n    SELECT\r\n        jsonb_agg(\r\n            to_jsonb(e) ||\r\n            jsonb_build_object(\r\n                'muscles', (\r\n                    SELECT jsonb_agg(jsonb_build_object('muscle', em.muscle_group, 'engagement', em.engagement_level))\r\n                    FROM public.exercise_muscle em\r\n                    WHERE em.exercise_id = e.id\r\n                ),\r\n                -- THE NEW PART: Aggregate all tags for this exercise\r\n                'tags', (\r\n                    SELECT jsonb_agg(t)\r\n                    FROM public.exercise_tags et\r\n                    JOIN public.tags t ON et.tag_id = t.id\r\n                    WHERE et.exercise_id = e.id\r\n                )\r\n            )\r\n        )\r\n    FROM (\r\n        -- The subquery for filtering remains the same\r\n        SELECT *\r\n        FROM exercises e\r\n        WHERE\r\n            (p_search_term IS NULL OR e.name ILIKE ('%' || p_search_term || '%'))\r\n            AND (p_difficulty_level IS NULL OR e.difficulty_level = p_difficulty_level)\r\n            AND (p_muscle_groups IS NULL OR EXISTS (\r\n                SELECT 1 FROM public.exercise_muscle em\r\n                WHERE em.exercise_id = e.id AND em.muscle_group::TEXT = ANY(p_muscle_groups)\r\n            ))\r\n            AND (p_tag_ids IS NULL OR EXISTS (\r\n                SELECT 1 FROM public.exercise_tags et\r\n                WHERE et.exercise_id = e.id AND et.tag_id = ANY(p_tag_ids)\r\n            ))\r\n        ORDER BY e.name\r\n        LIMIT p_page_limit\r\n        OFFSET p_page_offset\r\n    ) AS e;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_filtered_plans_rich",
    "arguments": "p_search_term text DEFAULT NULL::text, p_tag_ids integer[] DEFAULT NULL::integer[], p_difficulty_level integer DEFAULT NULL::integer, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n    SELECT jsonb_agg(plan_data)\r\n    FROM (\r\n        SELECT\r\n            p.*,\r\n            to_jsonb(pas) as analytics,\r\n            to_jsonb(creator) as creator\r\n        FROM plans p\r\n        JOIN profiles creator on p.created_by = creator.id\r\n        LEFT JOIN plan_analytics_summary pas ON p.id = pas.plan_id\r\n        WHERE\r\n            p.private = false\r\n            AND (p_search_term IS NULL OR p.title ILIKE ('%' || p_search_term || '%'))\r\n            AND (p_difficulty_level IS NULL OR p.difficulty_level = p.difficulty_level)\r\n            AND (p_tag_ids IS NULL OR EXISTS (\r\n                SELECT 1 FROM plan_weeks pw\r\n                JOIN plan_days pd ON pw.id = pd.plan_week_id\r\n                JOIN plan_sessions ps ON pd.id = ps.plan_day_id\r\n                JOIN plan_session_exercises pse ON ps.id = pse.plan_session_id\r\n                JOIN exercise_tags et ON pse.exercise_id = et.exercise_id\r\n                WHERE pw.plan_id = p.id AND et.tag_id = ANY(p_tag_ids)\r\n            ))\r\n        ORDER BY pas.active_users_count DESC NULLS LAST, p.created_at DESC\r\n        LIMIT p_page_limit\r\n        OFFSET p_page_offset\r\n    ) AS plan_data;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_filtered_teams_rich",
    "arguments": "p_search_term text DEFAULT NULL::text, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n    SELECT jsonb_agg(team_data)\r\n    FROM (\r\n        SELECT\r\n            t.*,\r\n            -- We can eventually add a team_analytics_summary view here\r\n            (SELECT COUNT(*) FROM team_members tm WHERE tm.team_id = t.id) as members_count,\r\n            (SELECT COUNT(*) FROM plans p WHERE p.team_id = t.id AND p.private = false) as plans_count\r\n        FROM teams t\r\n        WHERE\r\n            t.is_private = false\r\n            AND t.is_personal_workspace = false\r\n            AND (p_search_term IS NULL OR t.name ILIKE ('%' || p_search_term || '%'))\r\n        ORDER BY t.created_at DESC\r\n        LIMIT p_page_limit\r\n        OFFSET p_page_offset\r\n    ) AS team_data;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_filtered_users_rich",
    "arguments": "p_search_term text DEFAULT NULL::text, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n    SELECT jsonb_agg(user_data)\r\n    FROM (\r\n        SELECT\r\n            p.*,\r\n            to_jsonb(cas) as analytics\r\n        FROM profiles p\r\n        -- This join ensures we only get users who have created public content\r\n        -- and have analytics available.\r\n        JOIN coach_analytics_summary cas ON p.id = cas.coach_id\r\n        WHERE\r\n            (p_search_term IS NULL OR p.full_name ILIKE ('%' || p_search_term || '%') OR p.username ILIKE ('%' || p_search_term || '%'))\r\n        ORDER BY cas.total_likes_on_plans DESC NULLS LAST, p.full_name\r\n        LIMIT p_page_limit\r\n        OFFSET p_page_offset\r\n    ) AS user_data;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_my_logbook",
    "arguments": "",
    "return_type": "record",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n  SELECT\r\n    sl.id as log_id,\r\n    sl.date as workout_date,\r\n    sl.title as session_title, -- The title from the session_logs table\r\n    p.title as plan_title, -- The title from the joined plans table\r\n    sl.duration_minutes,\r\n    sl.overall_feeling,\r\n    sl.plan_id\r\n  FROM\r\n    public.session_logs sl\r\n  LEFT JOIN -- Use a LEFT JOIN in case it's an ad-hoc workout (plan_id is null)\r\n    public.plans p ON sl.plan_id = p.id\r\n  WHERE\r\n    sl.user_id = auth.uid() -- Explicitly use auth.uid()\r\n    AND sl.status = 'completed'\r\n  ORDER BY\r\n    sl.date DESC,        -- Most recent date first\r\n    sl.created_at DESC;  -- If multiple workouts on the same day, most recent time first\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_my_plan_history",
    "arguments": "",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nSELECT\r\n    jsonb_agg(plan_history)\r\nFROM (\r\n    SELECT\r\n        p.*,\r\n        MIN(sl.date) as first_logged_date,\r\n        MAX(sl.date) as last_logged_date\r\n    FROM\r\n        session_logs sl\r\n        JOIN plan_sessions ps ON sl.plan_session_id = ps.id\r\n        JOIN plan_days pd ON ps.plan_day_id = pd.id\r\n        JOIN plan_weeks pw ON pd.plan_week_id = pw.id\r\n        JOIN plans p ON pw.plan_id = p.id\r\n    WHERE\r\n        sl.user_id = auth.uid() -- Explicitly use auth.uid()\r\n        AND sl.plan_session_id IS NOT NULL\r\n    GROUP BY\r\n        p.id\r\n    ORDER BY\r\n        last_logged_date DESC\r\n) AS plan_history;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_my_plan_performance_summary_list",
    "arguments": "",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n  SELECT\r\n    jsonb_agg(\r\n      jsonb_build_object(\r\n        'plan_details', plan_info,\r\n        'performance_summary', perf_summary\r\n      )\r\n    )\r\n  FROM (\r\n    SELECT\r\n      ups.plan_id,\r\n      ups.id AS user_plan_status_id,\r\n      ups.status AS user_status_on_plan,\r\n      -- Aggregate all plan details into a single JSON object\r\n      jsonb_build_object(\r\n        'id', p.id,\r\n        'title', p.title,\r\n        'description', p.description,\r\n        'difficulty_level', p.difficulty_level\r\n      ) AS plan_info,\r\n      -- Aggregate all performance calculations into a single JSON object\r\n      jsonb_build_object(\r\n        'total_sessions_in_plan', (\r\n          SELECT COUNT(*)\r\n          FROM public.plan_sessions ps\r\n          JOIN public.plan_days pd ON ps.plan_day_id = pd.id\r\n          JOIN public.plan_weeks pw ON pd.plan_week_id = pw.id\r\n          WHERE pw.plan_id = p.id AND pd.is_rest_day = false\r\n        ),\r\n        'logged_sessions_count', (\r\n          SELECT COUNT(*)\r\n          FROM public.session_logs sl\r\n          WHERE sl.plan_id = p.id AND sl.user_id = auth.uid() AND sl.status = 'completed' -- Explicitly use auth.uid()\r\n        ),\r\n        'total_volume_kg', (\r\n          SELECT SUM(COALESCE(stl.reps_performed, 0) * COALESCE(stl.weight_used, 0))\r\n          FROM public.set_logs stl\r\n          JOIN public.session_exercise_logs sel ON stl.session_exercise_log_id = sel.id\r\n          JOIN public.session_logs sl ON sel.session_log_id = sl.id\r\n          WHERE sl.plan_id = p.id AND sl.user_id = auth.uid() -- Explicitly use auth.uid()\r\n        ),\r\n        'first_workout_date', (\r\n          SELECT MIN(sl.date)\r\n          FROM public.session_logs sl\r\n          WHERE sl.plan_id = p.id AND sl.user_id = auth.uid() -- Explicitly use auth.uid()\r\n        ),\r\n        'last_workout_date', (\r\n          SELECT MAX(sl.date)\r\n          FROM public.session_logs sl\r\n          WHERE sl.plan_id = p.id AND sl.user_id = auth.uid() -- Explicitly use auth.uid()\r\n        )\r\n      ) AS perf_summary\r\n    FROM\r\n      public.user_plan_status ups\r\n    JOIN\r\n      public.plans p ON ups.plan_id = p.id\r\n    WHERE\r\n      ups.user_id = auth.uid() -- Explicitly use auth.uid()\r\n    ORDER BY\r\n      ups.started_at DESC\r\n  ) AS user_plans_with_performance;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_pending_baselines_for_session",
    "arguments": "p_plan_session_id uuid",
    "return_type": "record",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nSELECT\r\n    upgp.id as progress_id,\r\n    pg.title as goal_title,\r\n    pg.metric,\r\n    ex.name as exercise_name\r\nFROM\r\n    public.user_plan_goal_progress upgp\r\nJOIN\r\n    public.plan_goals pg ON upgp.plan_goal_id = pg.id\r\nLEFT JOIN\r\n    public.exercises ex ON pg.exercise_id = ex.id\r\nWHERE\r\n    upgp.user_id = auth.uid()\r\n    AND upgp.status = 'pending_baseline'\r\n    -- This is the key part: find goals linked to exercises in THIS specific session\r\n    AND pg.exercise_id IN (\r\n        SELECT pse.exercise_id\r\n        FROM public.plan_session_exercises pse\r\n        WHERE pse.plan_session_id = p_plan_session_id\r\n    );\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_plan_details_for_user",
    "arguments": "p_plan_id uuid",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nSELECT\r\n    jsonb_build_object(\r\n        'plan', to_jsonb(p),\r\n        'creator', to_jsonb(creator_profile),\r\n        'team', to_jsonb(t),\r\n        'goals', (\r\n            SELECT jsonb_agg(\r\n                to_jsonb(g) || \r\n                jsonb_build_object('exercise_details', jsonb_build_object('id', ex.id, 'name', ex.name))\r\n            )\r\n            FROM public.plan_goals g\r\n            LEFT JOIN public.exercises ex ON g.exercise_id = ex.id\r\n            WHERE g.plan_id = p.id\r\n        ),\r\n        'can_edit', (\r\n            p.created_by = auth.uid() OR \r\n            (p.team_id IS NOT NULL AND EXISTS (\r\n                SELECT 1 \r\n                FROM public.team_members tm \r\n                WHERE tm.team_id = p.team_id AND tm.user_id = auth.uid() AND tm.role IN ('admin', 'coach')\r\n            ))\r\n        ),\r\n        'required_equipment', (\r\n            SELECT jsonb_agg(DISTINCT t_equip)\r\n            FROM public.plan_weeks pw\r\n            JOIN public.plan_days pd ON pw.id = pd.plan_week_id\r\n            JOIN public.plan_sessions ps ON pd.id = ps.plan_day_id\r\n            JOIN public.plan_session_exercises pse ON ps.id = pse.plan_session_id\r\n            JOIN public.exercise_tags et ON pse.exercise_id = et.exercise_id\r\n            JOIN public.tags t_equip ON et.tag_id = t_equip.id\r\n            WHERE pw.plan_id = p.id AND t_equip.tag_type = 'equipment'\r\n        ),\r\n        'user_plan_status', (\r\n            SELECT to_jsonb(ups)\r\n            FROM public.user_plan_status ups\r\n            WHERE ups.user_id = auth.uid() AND ups.plan_id = p.id\r\n            LIMIT 1\r\n        ),\r\n        'hierarchy', (\r\n            SELECT jsonb_build_object(\r\n                'weeks', COALESCE(\r\n                    (SELECT jsonb_agg(w_data ORDER BY (w_data->>'week_number')::int)\r\n                    FROM (\r\n                        SELECT to_jsonb(w) || jsonb_build_object(\r\n                            'days', COALESCE(\r\n                                (SELECT jsonb_agg(d_data ORDER BY (d_data->>'day_number')::int)\r\n                                FROM (\r\n                                    SELECT to_jsonb(d) || jsonb_build_object(\r\n                                        'sessions', COALESCE(\r\n                                            (SELECT jsonb_agg(s_data ORDER BY (s_data->>'order_index')::int)\r\n                                            FROM (\r\n                                                SELECT to_jsonb(s) || jsonb_build_object(\r\n                                                    'exercises', COALESCE(\r\n                                                        (SELECT jsonb_agg(e_data ORDER BY (e_data->>'order_within_session')::int)\r\n                                                        FROM (\r\n                                                            SELECT to_jsonb(pse) || jsonb_build_object(\r\n                                                                'exercise_details', to_jsonb(ex),\r\n                                                                'sets', COALESCE(\r\n                                                                    (SELECT jsonb_agg(pses ORDER BY pses.set_number)\r\n                                                                    FROM public.plan_session_exercise_sets pses\r\n                                                                    WHERE pses.plan_session_exercise_id = pse.id),\r\n                                                                    '[]'::jsonb\r\n                                                                )\r\n                                                            ) as e_data\r\n                                                            FROM public.plan_session_exercises pse\r\n                                                            JOIN public.exercises ex ON pse.exercise_id = ex.id\r\n                                                            WHERE pse.plan_session_id = s.id\r\n                                                        ) as exercises_subquery),\r\n                                                        '[]'::jsonb\r\n                                                    )\r\n                                                ) as s_data\r\n                                                FROM public.plan_sessions s\r\n                                                WHERE s.plan_day_id = d.id\r\n                                            ) as sessions_subquery),\r\n                                            '[]'::jsonb\r\n                                        )\r\n                                    ) as d_data\r\n                                    FROM public.plan_days d\r\n                                    WHERE d.plan_week_id = w.id\r\n                                ) as days_subquery),\r\n                                '[]'::jsonb\r\n                            )\r\n                        ) as w_data\r\n                        FROM public.plan_weeks w\r\n                        WHERE w.plan_id = p.id\r\n                    ) as weeks_subquery),\r\n                    '[]'::jsonb\r\n                )\r\n            )\r\n        )\r\n    )\r\nFROM\r\n    public.plans p\r\nJOIN\r\n    public.profiles creator_profile ON p.created_by = creator_profile.id\r\nLEFT JOIN\r\n    public.teams t ON p.team_id = t.id\r\nWHERE\r\n    p.id = p_plan_id;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_plan_session_details",
    "arguments": "p_plan_session_id uuid",
    "return_type": "json",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n  SELECT\r\n    json_build_object(\r\n      'id', ps.id,\r\n      'plan_day_id', ps.plan_day_id,\r\n      'order_index', ps.order_index,\r\n      'title', ps.title,\r\n      'notes', ps.notes,\r\n      'created_at', ps.created_at,\r\n      'updated_at', ps.updated_at,\r\n      'is_completed_by_user', false, -- This needs more complex logic if you track completion\r\n      'exercises', (\r\n        SELECT json_agg(\r\n          json_build_object(\r\n            'id', pse.id,\r\n            'plan_session_id', pse.plan_session_id,\r\n            'exercise_id', pse.exercise_id,\r\n            'order_within_session', pse.order_within_session,\r\n            'notes', pse.notes,\r\n            'created_at', pse.created_at,\r\n            'updated_at', pse.updated_at,\r\n            'execution_group', pse.execution_group,\r\n            'post_exercise_rest_seconds', pse.post_exercise_rest_seconds,\r\n            'post_group_rest_seconds', pse.post_group_rest_seconds,\r\n            'exercise_details', json_build_object(\r\n                'id', ex.id,\r\n                'name', ex.name,\r\n                'image_url', ex.image_url\r\n            ),\r\n            'sets', (\r\n                SELECT json_agg(\r\n                    sets.*\r\n                )\r\n                FROM public.plan_session_exercise_sets AS sets\r\n                WHERE sets.plan_session_exercise_id = pse.id\r\n            )\r\n          )\r\n        )\r\n        FROM public.plan_session_exercises AS pse\r\n        JOIN public.exercises AS ex ON pse.exercise_id = ex.id\r\n        WHERE pse.plan_session_id = ps.id\r\n      )\r\n    )\r\n  FROM public.plan_sessions AS ps\r\n  WHERE ps.id = p_plan_session_id;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_plan_user_performance_list",
    "arguments": "p_plan_id uuid",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n    SELECT\r\n        jsonb_agg(\r\n            jsonb_build_object(\r\n                'profile', to_jsonb(prof),\r\n                'performance', to_jsonb(uperf)\r\n            )\r\n            ORDER BY uperf.goal_achievement_percentage DESC, uperf.completion_percentage DESC, uperf.last_activity_date DESC\r\n        )\r\n    FROM public.user_plan_performance_summary uperf\r\n    JOIN public.profiles prof ON uperf.user_id = prof.id\r\n    WHERE uperf.plan_id = p_plan_id;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_session_log",
    "arguments": "p_session_log_id uuid",
    "return_type": "session_logs",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n    SELECT *\r\n    FROM public.session_logs\r\n    WHERE id = p_session_log_id AND user_id = auth.uid();\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_team_details_and_members",
    "arguments": "p_team_id uuid",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n    SELECT jsonb_build_object(\r\n        'team', to_jsonb(t),\r\n        'members', (\r\n            SELECT jsonb_agg(jsonb_build_object('profile', p, 'role', tm.role) ORDER BY tm.role, p.full_name)\r\n            FROM team_members tm\r\n            JOIN profiles p ON tm.user_id = p.id\r\n            WHERE tm.team_id = p_team_id\r\n        ),\r\n        'plans', (\r\n            SELECT jsonb_agg(p ORDER BY p.title)\r\n            FROM plans p\r\n            WHERE p.team_id = p_team_id\r\n        ),\r\n        -- NEW: Add the current user's role within this team.\r\n        -- This makes the function a complete replacement for get_workspace_data.\r\n        'current_user_role', (\r\n            SELECT tm.role\r\n            FROM team_members tm\r\n            WHERE tm.team_id = p_team_id AND tm.user_id = auth.uid()\r\n        )\r\n    )\r\n    FROM teams t\r\n    WHERE t.id = p_team_id;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_user_dashboard_summary",
    "arguments": "",
    "return_type": "jsonb",
    "language": "plpgsql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nDECLARE\r\n    v_active_plan_id UUID;\r\n    v_result JSONB;\r\n    v_current_user_profile public.profiles; -- To fetch current_workspace_id\r\nBEGIN\r\n    -- Fetch the user's profile to get current_workspace_id\r\n    SELECT * INTO v_current_user_profile\r\n    FROM public.profiles\r\n    WHERE id = auth.uid();\r\n\r\n    -- First, find the user's active plan ID (if any, as per previous logic)\r\n    SELECT plan_id INTO v_active_plan_id\r\n    FROM public.user_plan_status\r\n    WHERE user_id = auth.uid() AND status = 'active'\r\n    LIMIT 1; -- Assuming you still want one 'primary' active plan for dashboard overview, or remove LIMIT 1 to show multiple\r\n\r\n\r\n    -- Now, build the main JSONB object\r\n    SELECT jsonb_build_object(\r\n        'active_plan_details', (\r\n            SELECT\r\n                CASE\r\n                    WHEN v_active_plan_id IS NOT NULL THEN\r\n                        public.get_plan_details_for_user(v_active_plan_id)\r\n                    ELSE\r\n                        NULL\r\n                END\r\n        ),\r\n        'my_teams', (\r\n            SELECT jsonb_agg(\r\n                to_jsonb(t) || jsonb_build_object('role', tm.role)\r\n                ORDER BY t.name\r\n            )\r\n            FROM public.team_members tm\r\n            JOIN public.teams t ON tm.team_id = t.id\r\n            WHERE tm.user_id = auth.uid()\r\n        ),\r\n        'my_created_plans', (\r\n            SELECT jsonb_agg(p ORDER BY p.created_at DESC)\r\n            FROM public.plans p\r\n            WHERE p.created_by = auth.uid()\r\n        ),\r\n        'pending_invitations_count', (\r\n            SELECT COUNT(*)\r\n            FROM public.team_invitations ti\r\n            WHERE ti.invited_user_id = auth.uid() AND ti.status = 'pending'\r\n        ),\r\n        'current_workspace_id', v_current_user_profile.current_workspace_id -- <--- NEW FIELD\r\n    ) INTO v_result;\r\n\r\n    RETURN v_result;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_user_logbook",
    "arguments": "p_user_id uuid",
    "return_type": "record",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n  SELECT\r\n    sl.id as log_id,\r\n    sl.date as workout_date,\r\n    sl.title as session_title, -- The title from the session_logs table\r\n    p.title as plan_title, -- The title from the joined plans table\r\n    sl.duration_minutes,\r\n    sl.overall_feeling,\r\n    sl.plan_id\r\n  FROM\r\n    public.session_logs sl\r\n  LEFT JOIN -- Use a LEFT JOIN in case it's an ad-hoc workout (plan_id is null)\r\n    public.plans p ON sl.plan_id = p.id\r\n  WHERE\r\n    sl.user_id = p_user_id\r\n    AND sl.status = 'completed'\r\n  ORDER BY\r\n    sl.date DESC,        -- Most recent date first\r\n    sl.created_at DESC;  -- If multiple workouts on the same day, most recent time first\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_user_measurements",
    "arguments": "p_user_id uuid",
    "return_type": "user_measurements",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n    SELECT *\r\n    FROM public.user_measurements\r\n    WHERE user_id = p_user_id -- Ensure only the user's own measurements are fetched\r\n    ORDER BY measurement_date DESC, created_at DESC;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_user_plan_history",
    "arguments": "p_user_id uuid",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nSELECT\r\n    jsonb_agg(plan_history)\r\nFROM (\r\n    SELECT\r\n        p.*,\r\n        MIN(sl.date) as first_logged_date,\r\n        MAX(sl.date) as last_logged_date\r\n    FROM\r\n        session_logs sl\r\n        -- CORRECTED JOIN: Use the new 'plan_session_id' column\r\n        JOIN plan_sessions ps ON sl.plan_session_id = ps.id\r\n        JOIN plan_days pd ON ps.plan_day_id = pd.id\r\n        JOIN plan_weeks pw ON pd.plan_week_id = pw.id\r\n        JOIN plans p ON pw.plan_id = p.id\r\n    WHERE\r\n        sl.user_id = p_user_id\r\n        AND sl.plan_session_id IS NOT NULL\r\n    GROUP BY\r\n        p.id\r\n    ORDER BY\r\n        last_logged_date DESC\r\n) AS plan_history;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_user_plan_performance_details",
    "arguments": "p_user_plan_status_id uuid",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nSELECT\r\n  jsonb_build_object(\r\n    'plan', to_jsonb(p),\r\n    'goal_progress', (\r\n      SELECT jsonb_agg(\r\n        jsonb_build_object(\r\n          'progress_id', upgp.id,\r\n          'start_value', upgp.start_value,\r\n          'current_value', upgp.current_value,\r\n          'target_value', upgp.target_value, -- <-- THE FIX: Now reads from the correct table\r\n          'status', upgp.status,\r\n          'achieved_at', upgp.achieved_at,\r\n          'goal_definition', to_jsonb(pg) -- Embed the original goal blueprint\r\n        )\r\n      )\r\n      FROM user_plan_goal_progress upgp\r\n      JOIN plan_goals pg ON upgp.plan_goal_id = pg.id\r\n      JOIN user_plan_status ups ON upgp.user_id = ups.user_id AND pg.plan_id = ups.plan_id\r\n      WHERE ups.id = p_user_plan_status_id\r\n    )\r\n  )\r\nFROM\r\n  user_plan_status ups\r\n  JOIN plans p ON ups.plan_id = p.id\r\nWHERE\r\n  ups.id = p_user_plan_status_id AND ups.user_id = auth.uid();\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_user_plan_performance_summary_list",
    "arguments": "p_user_id uuid",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n  SELECT\r\n    jsonb_agg(\r\n      jsonb_build_object(\r\n        'plan_details', plan_info,\r\n        'performance_summary', perf_summary\r\n      )\r\n    )\r\n  FROM (\r\n    SELECT\r\n      ups.plan_id,\r\n      ups.id AS user_plan_status_id,\r\n      ups.status AS user_status_on_plan,\r\n      -- Aggregate all plan details into a single JSON object\r\n      jsonb_build_object(\r\n        'id', p.id,\r\n        'title', p.title,\r\n        'description', p.description,\r\n        'difficulty_level', p.difficulty_level\r\n      ) AS plan_info,\r\n      -- Aggregate all performance calculations into a single JSON object\r\n      jsonb_build_object(\r\n        'total_sessions_in_plan', (\r\n          SELECT COUNT(*)\r\n          FROM public.plan_sessions ps\r\n          JOIN public.plan_days pd ON ps.plan_day_id = pd.id\r\n          JOIN public.plan_weeks pw ON pd.plan_week_id = pw.id\r\n          WHERE pw.plan_id = p.id AND pd.is_rest_day = false\r\n        ),\r\n        'logged_sessions_count', (\r\n          SELECT COUNT(*)\r\n          FROM public.session_logs sl\r\n          WHERE sl.plan_id = p.id AND sl.user_id = p_user_id AND sl.status = 'completed'\r\n        ),\r\n        'total_volume_kg', (\r\n          SELECT SUM(COALESCE(stl.reps_performed, 0) * COALESCE(stl.weight_used, 0)) -- <-- THE FIX IS HERE\r\n          FROM public.set_logs stl\r\n          JOIN public.session_exercise_logs sel ON stl.session_exercise_log_id = sel.id\r\n          JOIN public.session_logs sl ON sel.session_log_id = sl.id\r\n          WHERE sl.plan_id = p.id AND sl.user_id = p_user_id\r\n        ),\r\n        'first_workout_date', (\r\n          SELECT MIN(sl.date)\r\n          FROM public.session_logs sl\r\n          WHERE sl.plan_id = p.id AND sl.user_id = p_user_id\r\n        ),\r\n        'last_workout_date', (\r\n          SELECT MAX(sl.date)\r\n          FROM public.session_logs sl\r\n          WHERE sl.plan_id = p.id AND sl.user_id = p_user_id\r\n        )\r\n      ) AS perf_summary\r\n    FROM\r\n      public.user_plan_status ups\r\n    JOIN\r\n      public.plans p ON ups.plan_id = p.id\r\n    WHERE\r\n      ups.user_id = p_user_id\r\n    ORDER BY\r\n      ups.started_at DESC\r\n  ) AS user_plans_with_performance;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_user_profile_details",
    "arguments": "p_user_id uuid",
    "return_type": "jsonb",
    "language": "plpgsql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nDECLARE\r\n    v_active_plan_id UUID;\r\n    v_result JSONB;\r\nBEGIN\r\n    SELECT plan_id INTO v_active_plan_id\r\n    FROM public.user_plan_status\r\n    WHERE user_id = p_user_id AND status = 'active'\r\n    LIMIT 1;\r\n\r\n    -- This CTE is now corrected to use the right column name\r\n    WITH latest_activity AS (\r\n        SELECT\r\n            pw.week_number,\r\n            pd.day_number\r\n        FROM session_logs sl\r\n        -- CORRECTED JOIN: Use the new 'plan_session_id' column\r\n        JOIN plan_sessions ps ON sl.plan_session_id = ps.id\r\n        JOIN plan_days pd ON ps.plan_day_id = pd.id\r\n        JOIN plan_weeks pw ON pd.plan_week_id = pw.id\r\n        WHERE sl.user_id = p_user_id\r\n          AND pw.plan_id = v_active_plan_id\r\n        ORDER BY sl.date DESC, sl.created_at DESC\r\n        LIMIT 1\r\n    )\r\n    SELECT jsonb_build_object(\r\n        'profile', to_jsonb(prof),\r\n        'teams', (\r\n            SELECT jsonb_agg(jsonb_build_object('team', t, 'role', tm.role))\r\n            FROM team_members tm\r\n            JOIN teams t ON tm.team_id = t.id\r\n            WHERE tm.user_id = p_user_id\r\n        ),\r\n        'active_plan_details', (\r\n            -- This part correctly calls the other function, so it's fine.\r\n            SELECT\r\n                CASE\r\n                    WHEN v_active_plan_id IS NOT NULL THEN\r\n                        public.get_plan_details_for_user(v_active_plan_id)\r\n                    ELSE\r\n                        NULL\r\n                END\r\n        )\r\n    )\r\n    INTO v_result\r\n    FROM public.profiles prof\r\n    WHERE prof.id = p_user_id;\r\n\r\n    RETURN v_result;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_user_workout_dates",
    "arguments": "p_user_id uuid",
    "return_type": "date",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n  SELECT DISTINCT\r\n    sl.date\r\n  FROM\r\n    public.session_logs sl\r\n  WHERE\r\n    sl.user_id = p_user_id\r\n    AND sl.status = 'completed'\r\n  ORDER BY\r\n    sl.date;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_workout_details",
    "arguments": "p_log_id uuid",
    "return_type": "jsonb",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nSELECT\r\n    jsonb_build_object(\r\n        'log_summary', to_jsonb(sl),\r\n        'performed_exercises', (\r\n            SELECT jsonb_agg(\r\n                jsonb_build_object(\r\n                    'exercise_details', to_jsonb(ex),\r\n                    'log_details', to_jsonb(sel),\r\n                    'sets_logged', (\r\n                        SELECT jsonb_agg(slog ORDER BY slog.set_number)\r\n                        FROM set_logs slog\r\n                        WHERE slog.session_exercise_log_id = sel.id\r\n                    )\r\n                )\r\n            )\r\n            FROM session_exercise_logs sel\r\n            JOIN exercises ex ON sel.exercise_id = ex.id\r\n            WHERE sel.session_log_id = sl.id\r\n        )\r\n    )\r\nFROM\r\n    session_logs sl\r\nWHERE\r\n    sl.id = p_log_id;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_workout_player_data",
    "arguments": "p_session_log_id uuid",
    "return_type": "jsonb",
    "language": "plpgsql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nDECLARE\r\n    v_session_log public.session_logs;\r\n    v_plan_session_id UUID;\r\n    v_full_plan_details JSONB;\r\nBEGIN\r\n    -- Fetch the session log itself\r\n    SELECT * INTO v_session_log\r\n    FROM public.session_logs\r\n    WHERE id = p_session_log_id AND user_id = auth.uid();\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Session log not found or not owned by user.';\r\n    END IF;\r\n\r\n    -- Get the plan_session_id from the fetched log\r\n    v_plan_session_id := v_session_log.plan_session_id;\r\n\r\n    -- Fetch the full plan details if a plan session was associated\r\n    IF v_plan_session_id IS NOT NULL THEN\r\n        SELECT public.get_plan_details_for_user(pw.plan_id) INTO v_full_plan_details\r\n        FROM public.plan_sessions ps\r\n        JOIN public.plan_days pd ON ps.plan_day_id = pd.id\r\n        JOIN public.plan_weeks pw ON pd.plan_week_id = pw.id\r\n        WHERE ps.id = v_plan_session_id;\r\n    ELSE\r\n        v_full_plan_details := NULL;\r\n    END IF;\r\n\r\n    -- Return the aggregated data\r\n    RETURN jsonb_build_object(\r\n        'session_log', to_jsonb(v_session_log),\r\n        'plan_details', v_full_plan_details\r\n    );\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "handle_new_user",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n  _username_base TEXT := COALESCE(NEW.raw_user_meta_data ->> 'username', split_part(NEW.email, '@', 1));\r\n  _full_name TEXT := NEW.raw_user_meta_data ->> 'full_name';\r\n  _final_username TEXT;\r\n  _new_team_id UUID;\r\nBEGIN\r\n  -- 1. Create a guaranteed unique username.\r\n  _final_username := _username_base || '_' || substr(md5(random()::text), 1, 6);\r\n\r\n  -- 2. Create the user's profile.\r\n  INSERT INTO public.profiles (id, username, full_name, email)\r\n  VALUES (NEW.id, _final_username, _full_name, NEW.email);\r\n\r\n  -- 3. Create the user's protected \"Home Workspace\" team.\r\n  INSERT INTO public.teams (name, created_by, is_personal_workspace)\r\n  VALUES (_final_username || '''s Workspace', NEW.id, true)\r\n  RETURNING id INTO _new_team_id;\r\n\r\n  -- 4. Make the user the admin of their new workspace.\r\n  -- This step is now safe because the conflicting trigger and FK are gone.\r\n  INSERT INTO public.team_members (user_id, team_id, role)\r\n  VALUES (NEW.id, _new_team_id, 'admin');\r\n\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "insert_user_measurement",
    "arguments": "p_measurement_data jsonb",
    "return_type": "user_measurements",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    v_user_id UUID := auth.uid();\r\n    new_measurement public.user_measurements;\r\nBEGIN\r\n    -- Insert the new measurement, populating user_id and created_at automatically.\r\n    -- Use COALESCE with current_date for measurement_date if not provided in JSONB.\r\n    INSERT INTO public.user_measurements (\r\n        user_id,\r\n        measurement_date,\r\n        weight_kg,\r\n        height_cm,\r\n        body_fat_percentage,\r\n        resting_heart_rate,\r\n        biceps_left_cm,\r\n        biceps_left_photo_url,\r\n        biceps_right_cm,\r\n        biceps_right_photo_url,\r\n        waist_cm,\r\n        waist_photo_url,\r\n        chest_cm,\r\n        chest_photo_url,\r\n        thigh_left_cm,\r\n        thigh_left_photo_url,\r\n        thigh_right_cm,\r\n        thigh_right_photo_url,\r\n        calf_left_cm,\r\n        calf_left_photo_url,\r\n        calf_right_cm,\r\n        calf_right_photo_url,\r\n        hips_cm,\r\n        hips_photo_url,\r\n        forearm_left_cm,\r\n        forearm_left_photo_url,\r\n        forearm_right_cm,\r\n        forearm_right_photo_url,\r\n        overall_notes\r\n    ) VALUES (\r\n        v_user_id,\r\n        COALESCE((p_measurement_data->>'measurement_date')::date, CURRENT_DATE),\r\n        (p_measurement_data->>'weight_kg')::numeric,\r\n        (p_measurement_data->>'height_cm')::numeric,\r\n        (p_measurement_data->>'body_fat_percentage')::numeric,\r\n        (p_measurement_data->>'resting_heart_rate')::integer,\r\n        (p_measurement_data->>'biceps_left_cm')::numeric,\r\n        (p_measurement_data->>'biceps_left_photo_url')::text,\r\n        (p_measurement_data->>'biceps_right_cm')::numeric,\r\n        (p_measurement_data->>'biceps_right_photo_url')::text,\r\n        (p_measurement_data->>'waist_cm')::numeric,\r\n        (p_measurement_data->>'waist_photo_url')::text,\r\n        (p_measurement_data->>'chest_cm')::numeric,\r\n        (p_measurement_data->>'chest_photo_url')::text,\r\n        (p_measurement_data->>'thigh_left_cm')::numeric,\r\n        (p_measurement_data->>'thigh_left_photo_url')::text,\r\n        (p_measurement_data->>'thigh_right_cm')::numeric,\r\n        (p_measurement_data->>'thigh_right_photo_url')::text,\r\n        (p_measurement_data->>'calf_left_cm')::numeric,\r\n        (p_measurement_data->>'calf_left_photo_url')::text,\r\n        (p_measurement_data->>'calf_right_cm')::numeric,\r\n        (p_measurement_data->>'calf_right_photo_url')::text,\r\n        (p_measurement_data->>'hips_cm')::numeric,\r\n        (p_measurement_data->>'hips_photo_url')::text,\r\n        (p_measurement_data->>'forearm_left_cm')::numeric,\r\n        (p_measurement_data->>'forearm_left_photo_url')::text,\r\n        (p_measurement_data->>'forearm_right_cm')::numeric,\r\n        (p_measurement_data->>'forearm_right_photo_url')::text,\r\n        (p_measurement_data->>'overall_notes')::text\r\n    )\r\n    RETURNING * INTO new_measurement;\r\n\r\n    RETURN new_measurement;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "invite_member_to_team",
    "arguments": "p_team_id uuid, p_role team_member_role, p_invited_user_id uuid DEFAULT NULL::uuid, p_invited_email text DEFAULT NULL::text",
    "return_type": "jsonb",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    v_inviter_id UUID := auth.uid();\r\n    v_final_user_id UUID := p_invited_user_id;\r\n    v_final_email TEXT := p_invited_email;\r\n    v_inviter_role team_member_role;\r\n    v_new_invitation_id UUID;\r\nBEGIN\r\n    -- ... (All security checks and logic are exactly the same as before) ...\r\n    IF p_invited_user_id IS NULL AND p_invited_email IS NULL THEN\r\n        RAISE EXCEPTION 'Either a user ID or an email must be provided.';\r\n    END IF;\r\n    SELECT role INTO v_inviter_role FROM public.team_members WHERE team_id = p_team_id AND user_id = v_inviter_id;\r\n    IF v_inviter_role IS NULL OR v_inviter_role NOT IN ('admin', 'coach') THEN\r\n        RAISE EXCEPTION 'Permission denied: Not an admin or coach of this team.';\r\n    END IF;\r\n    IF v_final_user_id IS NOT NULL THEN\r\n        SELECT email INTO v_final_email FROM auth.users WHERE id = v_final_user_id;\r\n        IF v_final_email IS NULL THEN RAISE EXCEPTION 'Invited user not found.'; END IF;\r\n    ELSE\r\n        SELECT id INTO v_final_user_id FROM auth.users WHERE email = v_final_email;\r\n    END IF;\r\n    IF v_final_user_id IS NOT NULL AND EXISTS (SELECT 1 FROM public.team_members WHERE team_id = p_team_id AND user_id = v_final_user_id) THEN\r\n        RAISE EXCEPTION 'This user is already a member of the team.';\r\n    END IF;\r\n\r\n    -- Create the invitation and capture the new ID\r\n    INSERT INTO public.team_invitations (team_id, invited_by, invited_email, invited_user_id, role)\r\n    VALUES (p_team_id, v_inviter_id, v_final_email, v_final_user_id, p_role)\r\n    RETURNING id INTO v_new_invitation_id;\r\n\r\n    -- THE KEY CHANGE: Return a structured JSON object with the ID.\r\n    RETURN jsonb_build_object('id', v_new_invitation_id);\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "log_workout",
    "arguments": "p_payload jsonb",
    "return_type": "void",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n  v_session_log_id uuid := (p_payload->>'session_log_id')::uuid;\r\n  v_user_id uuid;\r\n  v_plan_id uuid;\r\n  new_session_exercise_log_id uuid;\r\n  exercise_log jsonb;\r\n  set_log jsonb;\r\n  v_goal_progress record;\r\n  v_recalculated_value numeric;\r\nBEGIN\r\n  -- Get user_id and plan_id from the session log for context AND PERFORM SECURITY CHECK\r\n  SELECT user_id, plan_id INTO v_user_id, v_plan_id\r\n  FROM public.session_logs\r\n  WHERE id = v_session_log_id AND user_id = auth.uid(); -- <-- ADDED SECURITY CHECK\r\n\r\n  IF NOT FOUND THEN\r\n      RAISE EXCEPTION 'Session log not found or not owned by the current user.';\r\n  END IF;\r\n\r\n  -- 1. Insert all the exercise and set logs (same as before)\r\n  FOR exercise_log IN SELECT * FROM jsonb_array_elements(p_payload->'performed_exercises')\r\n  LOOP\r\n    INSERT INTO public.session_exercise_logs (session_log_id, exercise_id, plan_session_exercise_id, notes)\r\n    VALUES (v_session_log_id, (exercise_log->>'exercise_id')::uuid, (exercise_log->>'plan_session_exercise_id')::uuid, exercise_log->>'notes')\r\n    RETURNING id INTO new_session_exercise_log_id;\r\n\r\n    IF jsonb_typeof(exercise_log->'sets') = 'array' THEN\r\n      FOR set_log IN SELECT * FROM jsonb_array_elements(exercise_log->'sets')\r\n      LOOP\r\n        INSERT INTO public.set_logs (session_exercise_log_id, set_number, reps_performed, weight_used, performance_metadata)\r\n        VALUES (new_session_exercise_log_id, (set_log->>'set_number')::smallint, (set_log->>'reps_performed')::smallint, (set_log->>'weight_used_kg')::numeric, set_log->'performance_metadata');\r\n      END LOOP;\r\n    END IF;\r\n  END LOOP;\r\n  \r\n  -- 2. Update goal progress if this was part of a plan\r\n  IF v_plan_id IS NOT NULL THEN\r\n    -- Find all 'in_progress' goals for this user on this plan\r\n    FOR v_goal_progress IN \r\n      SELECT upgp.*, pg.metric, pg.exercise_id, pg.target_type, pg.direction, pg.target_value AS plan_target_value\r\n      FROM public.user_plan_goal_progress upgp\r\n      JOIN public.plan_goals pg ON upgp.plan_goal_id = pg.id\r\n      WHERE upgp.user_id = v_user_id AND pg.plan_id = v_plan_id AND upgp.status = 'in_progress'\r\n    LOOP\r\n      v_recalculated_value := NULL;\r\n      \r\n      -- Recalculate the current value based on the goal's metric\r\n      IF v_goal_progress.metric = 'one_rep_max_kg' AND v_goal_progress.exercise_id IS NOT NULL THEN\r\n          SELECT MAX(sl.weight_used) INTO v_recalculated_value\r\n          FROM public.set_logs sl\r\n          JOIN public.session_exercise_logs sel ON sl.session_exercise_log_id = sel.id\r\n          JOIN public.session_logs s ON sel.session_log_id = s.id\r\n          WHERE s.user_id = v_user_id AND sel.exercise_id = v_goal_progress.exercise_id;\r\n      ELSIF v_goal_progress.metric = 'sessions_completed_count' THEN\r\n          SELECT COUNT(*) INTO v_recalculated_value \r\n          FROM public.session_logs \r\n          WHERE user_id = v_user_id AND plan_id = v_plan_id AND status = 'completed';\r\n      END IF;\r\n      \r\n      -- If we have a new value, update the progress record\r\n      IF v_recalculated_value IS NOT NULL THEN\r\n        UPDATE public.user_plan_goal_progress\r\n        SET current_value = v_recalculated_value\r\n        WHERE id = v_goal_progress.id;\r\n\r\n        -- Check if the goal has now been achieved\r\n        IF (v_goal_progress.direction = 'increase' AND v_recalculated_value >= v_goal_progress.target_value) OR\r\n           (v_goal_progress.direction = 'decrease' AND v_recalculated_value <= v_goal_progress.target_value) THEN\r\n          UPDATE public.user_plan_goal_progress\r\n          SET status = 'achieved', achieved_at = now()\r\n          WHERE id = v_goal_progress.id;\r\n        END IF;\r\n      END IF;\r\n    END LOOP;\r\n  END IF;\r\n\r\n  -- 3. Finally, update the main session log to mark it as 'completed'\r\n  UPDATE public.session_logs\r\n  SET status = 'completed', duration_minutes = (p_payload->>'duration_minutes')::integer,\r\n      overall_feeling = (p_payload->>'overall_feeling')::smallint, notes = p_payload->>'notes', updated_at = now()\r\n  WHERE id = v_session_log_id;\r\n\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "log_workout_session",
    "arguments": "p_session_log_id uuid, p_performed_exercises jsonb, p_duration_minutes integer, p_overall_feeling smallint, p_notes text",
    "return_type": "void",
    "language": "plpgsql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nDECLARE\r\n    exercise_data jsonb;\r\n    set_data jsonb;\r\n    new_session_exercise_log_id uuid;\r\nBEGIN\r\n    -- First, loop through each performed exercise in the JSON array\r\n    FOR exercise_data IN SELECT * FROM jsonb_array_elements(p_performed_exercises)\r\n    LOOP\r\n        -- Create a parent log entry for this exercise\r\n        INSERT INTO public.session_exercise_logs\r\n            (session_log_id, plan_session_exercise_id, exercise_id, notes)\r\n        VALUES\r\n            (p_session_log_id,\r\n             (exercise_data->>'plan_session_exercise_id')::uuid,\r\n             (exercise_data->>'exercise_id')::uuid,\r\n             exercise_data->>'notes'\r\n            )\r\n        RETURNING id INTO new_session_exercise_log_id;\r\n\r\n        -- Then, loop through each set for this exercise\r\n        FOR set_data IN SELECT * FROM jsonb_array_elements(exercise_data->'sets')\r\n        LOOP\r\n            INSERT INTO public.set_logs\r\n                (session_exercise_log_id, set_number, reps_performed, weight_used, duration_seconds, distance_meters, notes, performance_metadata)\r\n            VALUES\r\n                (new_session_exercise_log_id,\r\n                 (set_data->>'set_number')::smallint,\r\n                 (set_data->>'reps_performed')::smallint,\r\n                 (set_data->>'weight_used')::numeric,\r\n                 (set_data->>'duration_seconds')::integer,\r\n                 (set_data->>'distance_meters')::numeric,\r\n                 set_data->>'notes',\r\n                 set_data->'performance_metadata'\r\n                );\r\n        END LOOP;\r\n    END LOOP;\r\n\r\n    -- Finally, update the main session_log to mark it as complete\r\n    UPDATE public.session_logs\r\n    SET\r\n        status = 'completed',\r\n        duration_minutes = p_duration_minutes,\r\n        overall_feeling = p_overall_feeling,\r\n        notes = p_notes,\r\n        updated_at = now()\r\n    WHERE\r\n        id = p_session_log_id AND user_id = auth.uid();\r\n\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "mark_abandoned_plans",
    "arguments": "",
    "return_type": "void",
    "language": "sql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\n    UPDATE public.user_plan_status\r\n    SET status = 'abandoned'\r\n    WHERE\r\n        status = 'active'\r\n        -- CORRECTED LOGIC: Find plans where the last activity\r\n        -- was more than 2 days (48 hours) ago.\r\n        AND last_activity_at < now() - interval '2 days';\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "respond_to_team_invitation",
    "arguments": "p_invitation_id uuid, p_accepted boolean",
    "return_type": "void",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    v_invitation public.team_invitations;\r\n    v_user_id UUID := auth.uid();\r\nBEGIN\r\n    -- Fetch the invitation and verify the current user is the one invited.\r\n    SELECT * INTO v_invitation FROM public.team_invitations WHERE id = p_invitation_id;\r\n\r\n    IF v_invitation IS NULL THEN\r\n        RAISE EXCEPTION 'Invitation not found.';\r\n    END IF;\r\n\r\n    IF v_invitation.invited_user_id IS DISTINCT FROM v_user_id THEN\r\n        RAISE EXCEPTION 'Permission denied: This invitation is not for you.';\r\n    END IF;\r\n\r\n    IF v_invitation.status <> 'pending' THEN\r\n        RAISE EXCEPTION 'This invitation has already been responded to.';\r\n    END IF;\r\n\r\n    IF p_accepted THEN\r\n        -- User accepted: Update status and create the team membership.\r\n        UPDATE public.team_invitations SET status = 'accepted' WHERE id = p_invitation_id;\r\n        INSERT INTO public.team_members (team_id, user_id, role)\r\n        VALUES (v_invitation.team_id, v_user_id, v_invitation.role);\r\n    ELSE\r\n        -- User declined: Update status.\r\n        UPDATE public.team_invitations SET status = 'declined' WHERE id = p_invitation_id;\r\n    END IF;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "save_plan_changes",
    "arguments": "p_changeset jsonb",
    "return_type": "jsonb",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n  -- Variables to hold temporary IDs and newly created real IDs\r\n  temp_week_id text;\r\n  real_week_id uuid;\r\n  temp_day_id text;\r\n  real_day_id uuid;\r\n  temp_session_id text;\r\n  real_session_id uuid;\r\n  temp_exercise_id text;\r\n  real_exercise_id uuid;\r\n  -- Record variables to loop through JSON arrays\r\n  week_data jsonb;\r\n  day_data jsonb;\r\n  session_data jsonb;\r\n  exercise_data jsonb;\r\n  set_data jsonb;\r\n  -- The object we will return\r\n  id_map jsonb := '{}'::jsonb;\r\n  v_plan_id uuid := (p_changeset->>'planId')::uuid; -- Extract plan_id early\r\nBEGIN\r\n  -- CRITICAL SECURITY CHECK: Ensure the authenticated user can edit this plan\r\n  IF NOT public.user_can_edit_plan(v_plan_id) THEN\r\n      RAISE EXCEPTION 'Permission denied to modify this plan.';\r\n  END IF;\r\n\r\n  -- First, perform all DELETIONS in reverse order to respect foreign keys\r\n  -- If a week is deleted, its days, sessions, etc., will be deleted automatically by CASCADE.\r\n  -- We only need to delete the top-level items.\r\n  DELETE FROM public.plan_weeks WHERE id IN (SELECT value::uuid FROM jsonb_array_elements_text(p_changeset->'weeks'->'deleted'));\r\n  DELETE FROM public.plan_days WHERE id IN (SELECT value::uuid FROM jsonb_array_elements_text(p_changeset->'days'->'deleted'));\r\n  DELETE FROM public.plan_sessions WHERE id IN (SELECT value::uuid FROM jsonb_array_elements_text(p_changeset->'sessions'->'deleted'));\r\n  DELETE FROM public.plan_session_exercises WHERE id IN (SELECT value::uuid FROM jsonb_array_elements_text(p_changeset->'exercises'->'deleted'));\r\n  DELETE FROM public.plan_session_exercise_sets WHERE id IN (SELECT value::uuid FROM jsonb_array_elements_text(p_changeset->'sets'->'deleted'));\r\n\r\n  -- Second, perform all ADDITIONS, creating a map of temporary IDs to real IDs\r\n  -- WEEKS\r\n  FOR week_data IN SELECT * FROM jsonb_array_elements(p_changeset->'weeks'->'added')\r\n  LOOP\r\n    temp_week_id := week_data->>'id'; -- Get the temporary ID like \"temp-week-1\"\r\n    INSERT INTO public.plan_weeks (plan_id, week_number, description)\r\n    VALUES (v_plan_id, (week_data->>'week_number')::smallint, week_data->>'description') -- Use v_plan_id\r\n    RETURNING id INTO real_week_id;\r\n    \r\n    id_map := jsonb_set(id_map, ARRAY[temp_week_id], to_jsonb(real_week_id));\r\n  END LOOP;\r\n\r\n  -- DAYS\r\n  FOR day_data IN SELECT * FROM jsonb_array_elements(p_changeset->'days'->'added')\r\n  LOOP\r\n    temp_day_id := day_data->>'id';\r\n    -- Find the real week_id from our map, using the day's temporary parent ID\r\n    real_week_id := (id_map->>(day_data->>'plan_week_id'))::uuid;\r\n    \r\n    INSERT INTO public.plan_days (plan_week_id, day_number, title, description, is_rest_day)\r\n    VALUES (real_week_id, (day_data->>'day_number')::smallint, day_data->>'title', day_data->>'description', (day_data->>'is_rest_day')::boolean)\r\n    RETURNING id INTO real_day_id;\r\n    \r\n    id_map := jsonb_set(id_map, ARRAY[temp_day_id], to_jsonb(real_day_id));\r\n  END LOOP;\r\n\r\n  -- SESSIONS\r\n  FOR session_data IN SELECT * FROM jsonb_array_elements(p_changeset->'sessions'->'added')\r\n  LOOP\r\n    temp_session_id := session_data->>'id';\r\n    real_day_id := (id_map->>(session_data->>'plan_day_id'))::uuid;\r\n    \r\n    INSERT INTO public.plan_sessions (plan_day_id, order_index, title, notes)\r\n    VALUES (real_day_id, (session_data->>'order_index')::smallint, session_data->>'title', session_data->>'notes')\r\n    RETURNING id INTO real_session_id;\r\n\r\n    id_map := jsonb_set(id_map, ARRAY[temp_session_id], to_jsonb(real_session_id));\r\n  END LOOP;\r\n\r\n  -- EXERCISES\r\n  FOR exercise_data IN SELECT * FROM jsonb_array_elements(p_changeset->'exercises'->'added')\r\n  LOOP\r\n    temp_exercise_id := exercise_data->>'id';\r\n    real_session_id := (id_map->>(exercise_data->>'plan_session_id'))::uuid;\r\n    \r\n    INSERT INTO public.plan_session_exercises (plan_session_id, exercise_id, order_within_session, execution_group, notes)\r\n    VALUES (real_session_id, (exercise_data->>'exercise_id')::uuid, (exercise_data->>'order_within_session')::smallint, (exercise_data->>'execution_group')::smallint, exercise_data->>'notes')\r\n    RETURNING id INTO real_exercise_id;\r\n    \r\n    id_map := jsonb_set(id_map, ARRAY[temp_exercise_id], to_jsonb(real_exercise_id));\r\n  END LOOP;\r\n  \r\n  -- SETS\r\n  FOR set_data IN SELECT * FROM jsonb_array_elements(p_changeset->'sets'->'added')\r\n  LOOP\r\n    real_exercise_id := (id_map->>(set_data->>'plan_session_exercise_id'))::uuid;\r\n\r\n    INSERT INTO public.plan_session_exercise_sets (plan_session_exercise_id, set_number, set_type, target_reps, target_weight, target_rest_seconds)\r\n    VALUES (real_exercise_id, (set_data->>'set_number')::smallint, (set_data->>'set_type')::set_type, (set_data->>'target_reps')::smallint, (set_data->>'target_weight')::numeric, (set_data->>'target_rest_seconds')::integer);\r\n    -- No need to capture the ID for sets as they are the lowest level\r\n  END LOOP;\r\n\r\n  -- Third, we will handle UPDATES. (This part can be added later)\r\n  -- For now, we are only handling additions and deletions.\r\n\r\n  RETURN id_map;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "save_plan_hierarchy",
    "arguments": "p_plan_id uuid, p_hierarchy jsonb",
    "return_type": "void",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n  -- ID Mapping\r\n  id_map jsonb := '{}'::jsonb;\r\n\r\n  -- Temporary ID holders\r\n  temp_week_id text;\r\n  temp_day_id text;\r\n  temp_session_id text;\r\n  temp_exercise_id text;\r\n\r\n  -- Real (UUID) ID holders\r\n  real_week_id uuid;\r\n  real_day_id uuid;\r\n  real_session_id uuid;\r\n  real_exercise_id uuid;\r\n\r\n  -- Loop variables\r\n  week_data jsonb;\r\n  day_data jsonb;\r\n  session_data jsonb;\r\n  exercise_data jsonb;\r\n  set_data jsonb;\r\nBEGIN\r\n  -- CRITICAL SECURITY CHECK: Ensure the authenticated user can edit this plan\r\n  IF NOT public.user_can_edit_plan(p_plan_id) THEN\r\n      RAISE EXCEPTION 'Permission denied to modify this plan.';\r\n  END IF;\r\n\r\n  -- 1. DELETE the old hierarchy\r\n  DELETE FROM public.plan_weeks WHERE plan_id = p_plan_id;\r\n\r\n  -- 2. RE-CREATE the new hierarchy with correct ID mapping\r\n  IF jsonb_typeof(p_hierarchy->'weeks') = 'array' THEN\r\n    FOR week_data IN SELECT * FROM jsonb_array_elements(p_hierarchy->'weeks')\r\n    LOOP\r\n      temp_week_id := week_data->>'id';\r\n      INSERT INTO public.plan_weeks (plan_id, week_number, description)\r\n      VALUES (p_plan_id, (week_data->>'week_number')::smallint, week_data->>'description')\r\n      RETURNING id INTO real_week_id;\r\n      id_map := jsonb_set(id_map, ARRAY[temp_week_id], to_jsonb(real_week_id));\r\n\r\n      IF jsonb_typeof(week_data->'days') = 'array' THEN\r\n        FOR day_data IN SELECT * FROM jsonb_array_elements(week_data->'days')\r\n        LOOP\r\n          temp_day_id := day_data->>'id';\r\n          -- Use the real_week_id captured in THIS loop\r\n          INSERT INTO public.plan_days (plan_week_id, day_number, title, description, is_rest_day)\r\n          VALUES (real_week_id, (day_data->>'day_number')::smallint, day_data->>'title', day_data->>'description', (day_data->>'is_rest_day')::boolean)\r\n          RETURNING id INTO real_day_id;\r\n          id_map := jsonb_set(id_map, ARRAY[temp_day_id], to_jsonb(real_day_id));\r\n\r\n          IF jsonb_typeof(day_data->'sessions') = 'array' THEN\r\n            FOR session_data IN SELECT * FROM jsonb_array_elements(day_data->'sessions')\r\n            LOOP\r\n              temp_session_id := session_data->>'id';\r\n              -- Use the real_day_id captured in THIS loop\r\n              INSERT INTO public.plan_sessions (plan_day_id, order_index, title, notes)\r\n              VALUES (real_day_id, (session_data->>'order_index')::smallint, session_data->>'title', session_data->>'notes')\r\n              RETURNING id INTO real_session_id;\r\n              id_map := jsonb_set(id_map, ARRAY[temp_session_id], to_jsonb(real_session_id));\r\n\r\n              IF jsonb_typeof(session_data->'exercises') = 'array' THEN\r\n                FOR exercise_data IN SELECT * FROM jsonb_array_elements(session_data->'exercises')\r\n                LOOP\r\n                  temp_exercise_id := exercise_data->>'id';\r\n                  -- Use the real_session_id captured in THIS loop\r\n                  INSERT INTO public.plan_session_exercises (plan_session_id, exercise_id, order_within_session, execution_group, notes, post_exercise_rest_seconds, post_group_rest_seconds)\r\n                  VALUES (real_session_id, (exercise_data->>'exercise_id')::uuid, (exercise_data->>'order_within_session')::smallint, (exercise_data->>'execution_group')::smallint, exercise_data->>'notes', (exercise_data->>'post_exercise_rest_seconds')::integer, (exercise_data->>'post_group_rest_seconds')::integer)\r\n                  RETURNING id INTO real_exercise_id;\r\n                  id_map := jsonb_set(id_map, ARRAY[temp_exercise_id], to_jsonb(real_exercise_id));\r\n                  \r\n                  IF jsonb_typeof(exercise_data->'sets') = 'array' THEN\r\n                    FOR set_data IN SELECT * FROM jsonb_array_elements(exercise_data->'sets')\r\n                    LOOP\r\n                      -- Use the real_exercise_id captured in THIS loop\r\n                      INSERT INTO public.plan_session_exercise_sets (plan_session_exercise_id, set_number, set_type, target_reps, target_weight, target_duration_seconds, target_distance_meters, target_rest_seconds, notes)\r\n                      VALUES (real_exercise_id, (set_data->>'set_number')::smallint, (set_data->>'set_type')::set_type, (set_data->>'target_reps')::smallint, (set_data->>'target_weight')::numeric, (set_data->>'target_duration_seconds')::integer, (set_data->>'target_distance_meters')::numeric, (set_data->>'target_rest_seconds')::integer, set_data->>'notes');\r\n                    END LOOP;\r\n                  END IF;\r\n                END LOOP;\r\n              END IF;\r\n            END LOOP;\r\n          END IF;\r\n        END LOOP;\r\n      END IF;\r\n    END LOOP;\r\n  END IF;\r\n\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "set_current_user_workspace",
    "arguments": "p_workspace_id uuid DEFAULT NULL::uuid",
    "return_type": "void",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    v_user_id UUID := auth.uid();\r\n    v_is_member BOOLEAN;\r\nBEGIN\r\n    IF p_workspace_id IS NOT NULL THEN\r\n        -- Only perform membership check if a specific workspace ID is provided\r\n        SELECT EXISTS (\r\n            SELECT 1\r\n            FROM public.team_members\r\n            WHERE user_id = v_user_id AND team_id = p_workspace_id\r\n        ) INTO v_is_member;\r\n\r\n        IF NOT v_is_member THEN\r\n            RAISE EXCEPTION 'Permission denied: User is not a member of the specified workspace.';\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Update the user's profile with the new current_workspace_id (can be NULL)\r\n    UPDATE public.profiles\r\n    SET current_workspace_id = p_workspace_id\r\n    WHERE id = v_user_id;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "set_goal_baseline",
    "arguments": "p_progress_id uuid, p_baseline_value numeric",
    "return_type": "void",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n  v_goal_progress public.user_plan_goal_progress;\r\n  v_plan_goal public.plan_goals;\r\n  v_target_value numeric;\r\nBEGIN\r\n  -- Security Check: Ensure the user owns this goal progress record\r\n  SELECT * INTO v_goal_progress\r\n  FROM public.user_plan_goal_progress\r\n  WHERE id = p_progress_id AND user_id = auth.uid();\r\n\r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'Goal progress not found or permission denied.';\r\n  END IF;\r\n\r\n  -- Get the original plan goal's definition\r\n  SELECT * INTO v_plan_goal\r\n  FROM public.plan_goals\r\n  WHERE id = v_goal_progress.plan_goal_id;\r\n\r\n  -- Calculate the personalized target based on the user-submitted baseline\r\n  IF v_plan_goal.target_type = 'percent_change' THEN\r\n     IF v_plan_goal.direction = 'increase' THEN\r\n        v_target_value := p_baseline_value + (p_baseline_value * (v_plan_goal.target_value / 100));\r\n     ELSE -- 'decrease'\r\n        v_target_value := p_baseline_value - (p_baseline_value * (v_plan_goal.target_value / 100));\r\n     END IF;\r\n  ELSIF v_plan_goal.target_type = 'absolute_change' THEN\r\n    IF v_plan_goal.direction = 'increase' THEN\r\n        v_target_value := p_baseline_value + v_plan_goal.target_value;\r\n    ELSE -- 'decrease'\r\n        v_target_value := p_baseline_value - v_plan_goal.target_value;\r\n    END IF;\r\n  ELSE -- 'absolute_value'\r\n    v_target_value := v_plan_goal.target_value;\r\n  END IF;\r\n  \r\n  -- Update the user's record with the baseline, the new target, and set the status to in_progress\r\n  UPDATE public.user_plan_goal_progress\r\n  SET\r\n    start_value = p_baseline_value,\r\n    current_value = p_baseline_value,\r\n    target_value = v_target_value,\r\n    status = 'in_progress'\r\n  WHERE\r\n    id = p_progress_id;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "start_adhoc_workout",
    "arguments": "",
    "return_type": "session_logs",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n  INSERT INTO public.session_logs (user_id, date, status, title)\r\n  VALUES (auth.uid(), CURRENT_DATE, 'in_progress', 'Ad-hoc Workout')\r\n  RETURNING *;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "start_and_log_plan_session",
    "arguments": "p_plan_session_id uuid",
    "return_type": "session_logs",
    "language": "plpgsql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nDECLARE\r\n    v_plan_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    new_session_log public.session_logs;\r\nBEGIN\r\n    IF p_plan_session_id IS NULL THEN\r\n        RAISE EXCEPTION 'A valid session ID must be provided to start a workout.';\r\n    END IF;\r\n\r\n    -- Find the top-level plan_id from the session_id\r\n    SELECT pw.plan_id INTO v_plan_id\r\n    FROM public.plan_sessions ps\r\n    JOIN public.plan_days pd ON ps.plan_day_id = pd.id\r\n    JOIN public.plan_weeks pw ON pd.plan_week_id = pw.id\r\n    WHERE ps.id = p_plan_session_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Plan not found for the provided session ID.';\r\n    END IF;\r\n\r\n    -- Manage the user's status for THIS SPECIFIC PLAN (UPSERT logic)\r\n    INSERT INTO public.user_plan_status (user_id, plan_id, status, started_at, last_activity_at)\r\n    VALUES (v_user_id, v_plan_id, 'active', now(), now())\r\n    ON CONFLICT (user_id, plan_id)\r\n    DO UPDATE SET\r\n        status = 'active',\r\n        last_activity_at = now();\r\n\r\n    -- Create the new session log record\r\n    INSERT INTO public.session_logs (user_id, plan_session_id, date, status, plan_id)\r\n    VALUES (v_user_id, p_plan_session_id, now(), 'in_progress', v_plan_id)\r\n    RETURNING * INTO new_session_log;\r\n\r\n    RETURN NEXT new_session_log;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "start_new_workout_session",
    "arguments": "p_plan_session_id uuid",
    "return_type": "session_logs",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    v_plan_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    new_session_log session_logs;\r\nBEGIN\r\n    IF p_plan_session_id IS NULL THEN\r\n        RAISE EXCEPTION 'A valid session ID must be provided to start a workout.';\r\n    END IF;\r\n\r\n    -- Find the plan_id\r\n    SELECT pw.plan_id INTO v_plan_id\r\n    FROM public.plan_sessions ps\r\n    JOIN public.plan_days pd ON ps.plan_day_id = pd.id\r\n    JOIN public.plan_weeks pw ON pd.plan_week_id = pw.id\r\n    WHERE ps.id = p_plan_session_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Plan not found for the provided session ID.';\r\n    END IF;\r\n\r\n    -- FIXED: Handle the user_plan_status properly\r\n    -- First, set any existing active status for this plan to completed\r\n    UPDATE public.user_plan_status \r\n    SET status = 'completed', last_activity_at = now()\r\n    WHERE user_id = v_user_id AND plan_id = v_plan_id AND status = 'active';\r\n    \r\n    -- Then insert new active status\r\n    INSERT INTO public.user_plan_status (user_id, plan_id, status)\r\n    VALUES (v_user_id, v_plan_id, 'active');\r\n\r\n    -- End any existing active sessions first\r\n    UPDATE public.session_logs \r\n    SET status = 'completed', updated_at = now()\r\n    WHERE user_id = v_user_id AND status = 'in_progress';\r\n\r\n    -- Create new session\r\n    INSERT INTO public.session_logs (user_id, plan_session_id, date, status, plan_id)\r\n    VALUES (v_user_id, p_plan_session_id, CURRENT_DATE, 'in_progress', v_plan_id)\r\n    RETURNING * INTO new_session_log;\r\n\r\n    RETURN NEXT new_session_log;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "start_plan_for_user",
    "arguments": "p_plan_id uuid",
    "return_type": "user_plan_status",
    "language": "plpgsql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nDECLARE\r\n  v_user_id uuid := auth.uid();\r\n  v_goal record;\r\n  v_start_value numeric;\r\nBEGIN\r\n  -- Step 1: Create or update the main user_plan_status record\r\n  INSERT INTO public.user_plan_status (user_id, plan_id, status)\r\n  VALUES (v_user_id, p_plan_id, 'active')\r\n  ON CONFLICT (user_id, plan_id) DO UPDATE SET status = 'active', last_activity_at = now();\r\n\r\n  -- Step 2: Loop through all goals for this plan\r\n  FOR v_goal IN\r\n    SELECT * FROM public.plan_goals WHERE plan_id = p_plan_id\r\n  LOOP\r\n    v_start_value := NULL;\r\n\r\n    -- Calculate baseline (logic remains the same)\r\n    IF v_goal.metric = 'one_rep_max_kg' AND v_goal.exercise_id IS NOT NULL THEN\r\n      SELECT MAX(sl.weight_used) INTO v_start_value\r\n      FROM public.set_logs sl\r\n      JOIN public.session_exercise_logs sel ON sl.session_exercise_log_id = sel.id\r\n      JOIN public.session_logs s ON sel.session_log_id = s.id\r\n      WHERE s.user_id = v_user_id AND sel.exercise_id = v_goal.exercise_id;\r\n    END IF;\r\n    \r\n    -- --- THIS IS THE KEY CHANGE ---\r\n    -- Insert the user's personal goal tracking record, now including the plan_id\r\n    INSERT INTO public.user_plan_goal_progress (user_id, plan_id, plan_goal_id, start_value, current_value, status)\r\n    VALUES (\r\n        v_user_id, \r\n        p_plan_id, -- <-- Populate the new column\r\n        v_goal.id, \r\n        v_start_value, \r\n        v_start_value, \r\n        -- If we couldn't find a baseline, set status, otherwise default is 'in_progress'\r\n        CASE WHEN v_start_value IS NULL THEN 'pending_baseline'::goal_status ELSE 'in_progress'::goal_status END\r\n    );\r\n    -- We no longer need to do a separate UPDATE for the status, making this more efficient.\r\n    \r\n  END LOOP;\r\n  \r\n  -- Return the record the client expects\r\n  RETURN QUERY SELECT * FROM public.user_plan_status WHERE user_id = v_user_id AND plan_id = p_plan_id;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "start_plan_with_baselines",
    "arguments": "p_payload jsonb",
    "return_type": "user_plan_status",
    "language": "plpgsql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nDECLARE\r\n  p_plan_id uuid := (p_payload->>'plan_id')::uuid;\r\n  p_baselines jsonb := p_payload->'baselines';\r\n  v_user_id uuid := auth.uid();\r\n  v_goal record;\r\n  baseline jsonb; -- Changed to jsonb to iterate over the array\r\n  v_target_value numeric;\r\nBEGIN\r\n  -- Step 1: Create the main user_plan_status record.\r\n  INSERT INTO public.user_plan_status (user_id, plan_id, status)\r\n  VALUES (v_user_id, p_plan_id, 'active')\r\n  ON CONFLICT (user_id, plan_id) DO UPDATE SET status = 'active', last_activity_at = now();\r\n\r\n  -- Step 2: Loop through the baselines array provided in the payload.\r\n  FOR baseline IN SELECT * FROM jsonb_array_elements(p_baselines)\r\n  LOOP\r\n    -- Find the original goal's definition from the goal_id in the baseline object\r\n    SELECT * INTO v_goal\r\n    FROM public.plan_goals\r\n    WHERE id = (baseline->>'goal_id')::uuid;\r\n\r\n    -- Calculate the user's personalized target value\r\n    IF v_goal.target_type = 'percent_change' THEN\r\n      IF v_goal.direction = 'increase' THEN\r\n          v_target_value := (baseline->>'baseline_value')::numeric + ((baseline->>'baseline_value')::numeric * (v_goal.target_value / 100));\r\n      ELSE -- 'decrease'\r\n          v_target_value := (baseline->>'baseline_value')::numeric - ((baseline->>'baseline_value')::numeric * (v_goal.target_value / 100));\r\n      END IF;\r\n    ELSIF v_goal.target_type = 'absolute_change' THEN\r\n      IF v_goal.direction = 'increase' THEN\r\n          v_target_value := (baseline->>'baseline_value')::numeric + v_goal.target_value;\r\n      ELSE -- 'decrease'\r\n          v_target_value := (baseline->>'baseline_value')::numeric - v_goal.target_value;\r\n      END IF;\r\n    ELSE -- 'absolute_value'\r\n      v_target_value := v_goal.target_value;\r\n    END IF;\r\n\r\n    -- Insert the complete, personalized goal tracking record for the user.\r\n    INSERT INTO public.user_plan_goal_progress (user_id, plan_id, plan_goal_id, start_value, current_value, target_value, status)\r\n    VALUES (v_user_id, p_plan_id, (baseline->>'goal_id')::uuid, (baseline->>'baseline_value')::numeric, (baseline->>'baseline_value')::numeric, v_target_value, 'in_progress');\r\n  END LOOP;\r\n  \r\n  -- Return the main plan status record.\r\n  RETURN QUERY SELECT * FROM public.user_plan_status WHERE user_id = v_user_id AND plan_id = p_plan_id;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "start_plan_with_goals",
    "arguments": "p_plan_id uuid, p_baselines user_baseline[]",
    "return_type": "user_plan_status",
    "language": "plpgsql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nDECLARE\r\n  v_user_id uuid := auth.uid();\r\n  v_goal record;\r\n  baseline record;\r\n  v_target_value numeric;\r\nBEGIN\r\n  -- Step 1: Create the main user_plan_status record.\r\n  -- This makes the plan officially \"active\" for the user.\r\n  INSERT INTO public.user_plan_status (user_id, plan_id, status)\r\n  VALUES (v_user_id, p_plan_id, 'active')\r\n  ON CONFLICT (user_id, plan_id) DO UPDATE SET status = 'active', last_activity_at = now();\r\n\r\n  -- Step 2: Loop through the baselines provided by the user from the dialog.\r\n  FOREACH baseline IN ARRAY p_baselines\r\n  LOOP\r\n    -- Find the original goal's definition to get the calculation rules (e.g., \"increase by 15%\")\r\n    SELECT * INTO v_goal\r\n    FROM public.plan_goals\r\n    WHERE id = baseline.goal_id;\r\n\r\n    -- Calculate the user's personalized target value based on their submitted baseline.\r\n    IF v_goal.target_type = 'percent_change' THEN\r\n      IF v_goal.direction = 'increase' THEN\r\n          v_target_value := baseline.baseline_value + (baseline.baseline_value * (v_goal.target_value / 100));\r\n      ELSE -- 'decrease'\r\n          v_target_value := baseline.baseline_value - (baseline.baseline_value * (v_goal.target_value / 100));\r\n      END IF;\r\n    ELSIF v_goal.target_type = 'absolute_change' THEN\r\n      IF v_goal.direction = 'increase' THEN\r\n          v_target_value := baseline.baseline_value + v_goal.target_value;\r\n      ELSE -- 'decrease'\r\n          v_target_value := baseline.baseline_value - v_goal.target_value;\r\n      END IF;\r\n    ELSE -- 'absolute_value'\r\n      v_target_value := v_goal.target_value;\r\n    END IF;\r\n\r\n    -- Insert the complete, personalized goal tracking record for the user.\r\n    -- The status is immediately 'in_progress' because the baseline is now set.\r\n    INSERT INTO public.user_plan_goal_progress (user_id, plan_id, plan_goal_id, start_value, current_value, target_value, status)\r\n    VALUES (v_user_id, p_plan_id, baseline.goal_id, baseline.baseline_value, baseline.baseline_value, v_target_value, 'in_progress');\r\n  END LOOP;\r\n  \r\n  -- Return the main plan status record, as the client expects.\r\n  RETURN QUERY SELECT * FROM public.user_plan_status WHERE user_id = v_user_id AND plan_id = p_plan_id;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "start_user_plan",
    "arguments": "p_plan_id uuid",
    "return_type": "void",
    "language": "sql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\n    -- This uses the UNIQUE INDEX we created. It tries to insert a new 'active' plan.\r\n    -- If the user already has an active plan (violating the index), it updates\r\n    -- the existing row to point to this new plan instead.\r\n    INSERT INTO public.user_plan_status (user_id, plan_id, status, last_activity_at)\r\n    VALUES (auth.uid(), p_plan_id, 'active', now())\r\n    ON CONFLICT (user_id) WHERE (status = 'active')\r\n    DO UPDATE SET\r\n        plan_id = EXCLUDED.plan_id,\r\n        started_at = now(),\r\n        last_activity_at = now();\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "start_workout_session",
    "arguments": "p_plan_session_id uuid",
    "return_type": "session_logs",
    "language": "plpgsql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nDECLARE\r\n  v_session_log public.session_logs;\r\nBEGIN\r\n  INSERT INTO public.session_logs (user_id, date, status, plan_session_id)\r\n  VALUES (auth.uid(), CURRENT_DATE, 'in_progress', p_plan_session_id)\r\n  ON CONFLICT (user_id) WHERE status = 'in_progress' -- This must match the new index\r\n  DO UPDATE SET\r\n    status = 'in_progress', -- Ensure it's active\r\n    plan_session_id = EXCLUDED.plan_session_id, -- Update with new plan if necessary\r\n    updated_at = NOW()\r\n  RETURNING * INTO v_session_log;\r\n\r\n  RETURN v_session_log;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "trigger_set_timestamp",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nBEGIN\r\n  NEW.updated_at = NOW();\r\n  RETURN NEW;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_plan_day",
    "arguments": "p_day_id uuid, p_day_number smallint, p_title character varying DEFAULT NULL::character varying, p_description text DEFAULT NULL::text, p_is_rest_day boolean DEFAULT false",
    "return_type": "plan_days",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    updated_day public.plan_days;\r\n    v_plan_week_id UUID; -- <--- CORRECTED: Declared here\r\n    v_plan_id UUID;\r\n    v_plan_owner_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    v_user_role public.team_member_role;\r\n    v_plan_team_id UUID;\r\nBEGIN\r\n    -- Get plan_id from day, and plan owner/team for permission checks\r\n    SELECT pd.plan_week_id, pw.plan_id, p.created_by, p.team_id\r\n    INTO v_plan_week_id, v_plan_id, v_plan_owner_id, v_plan_team_id\r\n    FROM public.plan_days pd\r\n    JOIN public.plan_weeks pw ON pd.plan_week_id = pw.id\r\n    JOIN public.plans p ON pw.plan_id = p.id\r\n    WHERE pd.id = p_day_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Day with ID % not found.', p_day_id;\r\n    END IF;\r\n\r\n    -- Permission check: Must be the plan creator OR an admin/coach in the plan's team\r\n    IF v_plan_owner_id IS DISTINCT FROM v_user_id THEN\r\n        IF v_plan_team_id IS NOT NULL THEN\r\n            SELECT role INTO v_user_role FROM public.team_members\r\n            WHERE user_id = v_user_id AND team_id = v_plan_team_id;\r\n\r\n            IF v_user_role IS NULL OR v_user_role NOT IN ('admin', 'coach') THEN\r\n                RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n            END IF;\r\n        ELSE\r\n            RAISE EXCEPTION 'Permission denied: Not plan creator.';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Ensure day_number is unique within the week (excluding the current day being updated)\r\n    IF EXISTS (SELECT 1 FROM public.plan_days WHERE plan_week_id = v_plan_week_id AND day_number = p_day_number AND id IS DISTINCT FROM p_day_id) THEN\r\n        RAISE EXCEPTION 'A day with number % already exists for this week.', p_day_number;\r\n    END IF;\r\n\r\n    UPDATE public.plan_days\r\n    SET\r\n        day_number = p_day_number,\r\n        title = p_title,\r\n        description = p_description,\r\n        is_rest_day = p_is_rest_day\r\n    WHERE\r\n        id = p_day_id\r\n    RETURNING * INTO updated_day;\r\n\r\n    RETURN updated_day;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_plan_goal",
    "arguments": "p_goal_id uuid, p_title text, p_description text, p_metric goal_metric, p_target_value numeric, p_exercise_id uuid DEFAULT NULL::uuid",
    "return_type": "plan_goals",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n  updated_goal public.plan_goals;\r\n  v_plan_id UUID;\r\nBEGIN\r\n  -- Get the plan_id associated with the goal\r\n  SELECT plan_id INTO v_plan_id FROM public.plan_goals WHERE id = p_goal_id;\r\n\r\n  IF NOT FOUND THEN\r\n      RAISE EXCEPTION 'Plan Goal with ID % not found.', p_goal_id;\r\n  END IF;\r\n\r\n  -- Security Check: Ensure the user can edit the plan\r\n  IF NOT public.user_can_edit_plan(v_plan_id) THEN\r\n      RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n  END IF;\r\n\r\n  UPDATE public.plan_goals\r\n  SET\r\n    title = p_title,\r\n    description = p_description,\r\n    metric = p_metric,\r\n    target_value = p_target_value,\r\n    exercise_id = p_exercise_id\r\n  WHERE id = p_goal_id\r\n  RETURNING * INTO updated_goal;\r\n\r\n  RETURN updated_goal;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_plan_session",
    "arguments": "p_session_id uuid, p_order_index smallint, p_title character varying DEFAULT NULL::character varying, p_notes text DEFAULT NULL::text",
    "return_type": "plan_sessions",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    updated_session public.plan_sessions;\r\n    -- CORRECTED: Declare all variables at the beginning\r\n    v_plan_day_id UUID;\r\n    v_plan_week_id UUID;\r\n    v_plan_id UUID;\r\n    v_plan_owner_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    v_user_role public.team_member_role;\r\n    v_plan_team_id UUID;\r\nBEGIN\r\n    -- Get plan_day_id from session, then plan_id from day, and plan owner/team for permission checks\r\n    SELECT ps.plan_day_id, pd.plan_week_id, pw.plan_id, p.created_by, p.team_id\r\n    INTO v_plan_day_id, v_plan_week_id, v_plan_id, v_plan_owner_id, v_plan_team_id\r\n    FROM public.plan_sessions ps\r\n    JOIN public.plan_days pd ON ps.plan_day_id = pd.id\r\n    JOIN public.plan_weeks pw ON pd.plan_week_id = pw.id\r\n    JOIN public.plans p ON pw.plan_id = p.id\r\n    WHERE ps.id = p_session_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Plan Session with ID % not found.', p_session_id;\r\n    END IF;\r\n\r\n    -- Permission check: Must be the plan creator OR an admin/coach in the plan's team\r\n    IF v_plan_owner_id IS DISTINCT FROM v_user_id THEN\r\n        IF v_plan_team_id IS NOT NULL THEN\r\n            SELECT role INTO v_user_role FROM public.team_members\r\n            WHERE user_id = v_user_id AND team_id = v_plan_team_id;\r\n\r\n            IF v_user_role IS NULL OR v_user_role NOT IN ('admin', 'coach') THEN\r\n                RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n            END IF;\r\n        ELSE\r\n            RAISE EXCEPTION 'Permission denied: Not plan creator.';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Ensure order_index is unique within the day (excluding the current session being updated)\r\n    IF EXISTS (SELECT 1 FROM public.plan_sessions WHERE plan_day_id = v_plan_day_id AND order_index = p_order_index AND id IS DISTINCT FROM p_session_id) THEN\r\n        RAISE EXCEPTION 'A session with order index % already exists for this day.', p_order_index;\r\n    END IF;\r\n\r\n    UPDATE public.plan_sessions\r\n    SET\r\n        order_index = p_order_index,\r\n        title = p_title,\r\n        notes = p_notes\r\n    WHERE\r\n        id = p_session_id\r\n    RETURNING * INTO updated_session;\r\n\r\n    RETURN updated_session;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_plan_week",
    "arguments": "p_week_id uuid, p_week_number smallint, p_description text DEFAULT NULL::text",
    "return_type": "plan_weeks",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nDECLARE\r\n    updated_week public.plan_weeks;\r\n    v_plan_id UUID;\r\n    v_plan_owner_id UUID;\r\n    v_user_id UUID := auth.uid();\r\n    v_user_role public.team_member_role;\r\n    v_plan_team_id UUID;\r\nBEGIN\r\n    -- Get plan_id from week, and plan owner/team for permission checks\r\n    SELECT pw.plan_id, p.created_by, p.team_id\r\n    INTO v_plan_id, v_plan_owner_id, v_plan_team_id\r\n    FROM public.plan_weeks pw\r\n    JOIN public.plans p ON pw.plan_id = p.id\r\n    WHERE pw.id = p_week_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Week with ID % not found.', p_week_id;\r\n    END IF;\r\n\r\n    -- Permission check: Must be the plan creator OR an admin/coach in the plan's team\r\n    IF v_plan_owner_id IS DISTINCT FROM v_user_id THEN\r\n        IF v_plan_team_id IS NOT NULL THEN\r\n            SELECT role INTO v_user_role FROM public.team_members\r\n            WHERE user_id = v_user_id AND team_id = v_plan_team_id;\r\n\r\n            IF v_user_role IS NULL OR v_user_role NOT IN ('admin', 'coach') THEN\r\n                RAISE EXCEPTION 'Permission denied: Not plan creator or team admin/coach.';\r\n            END IF;\r\n        ELSE\r\n            RAISE EXCEPTION 'Permission denied: Not plan creator.';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Ensure week_number is unique within the plan (excluding the current week being updated)\r\n    IF EXISTS (SELECT 1 FROM public.plan_weeks WHERE plan_id = v_plan_id AND week_number = p_week_number AND id IS DISTINCT FROM p_week_id) THEN\r\n        RAISE EXCEPTION 'A week with number % already exists for this plan.', p_week_number;\r\n    END IF;\r\n\r\n    UPDATE public.plan_weeks\r\n    SET\r\n        week_number = p_week_number,\r\n        description = p_description\r\n    WHERE\r\n        id = p_week_id\r\n    RETURNING * INTO updated_week;\r\n\r\n    RETURN updated_week;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_user_profile",
    "arguments": "p_full_name text, p_username text, p_bio text, p_unit measure_unit",
    "return_type": "record",
    "language": "plpgsql",
    "security_type": "SECURITY DEFINER",
    "definition": "\r\nBEGIN\r\n  UPDATE public.profiles\r\n  SET\r\n    full_name = p_full_name,\r\n    username = p_username,\r\n    bio = p_bio,\r\n    unit = p_unit,\r\n    updated_at = now()\r\n  WHERE\r\n    profiles.id = auth.uid()\r\n  RETURNING *;\r\nEND;\r\n"
  },
  {
    "schema_name": "public",
    "function_name": "user_can_edit_plan",
    "arguments": "p_plan_id uuid",
    "return_type": "boolean",
    "language": "plpgsql",
    "security_type": "SECURITY INVOKER",
    "definition": "\r\nDECLARE\r\n    v_plan_owner_id UUID;\r\n    v_plan_team_id UUID;\r\n    v_user_role public.team_member_role;\r\n    v_user_id UUID := auth.uid();\r\nBEGIN\r\n    SELECT created_by, team_id\r\n    INTO v_plan_owner_id, v_plan_team_id\r\n    FROM public.plans\r\n    WHERE id = p_plan_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RETURN FALSE;\r\n    END IF;\r\n\r\n    IF v_plan_owner_id = v_user_id THEN\r\n        RETURN TRUE;\r\n    END IF;\r\n\r\n    IF v_plan_team_id IS NOT NULL THEN\r\n        SELECT role INTO v_user_role\r\n        FROM public.team_members\r\n        WHERE user_id = v_user_id AND team_id = v_plan_team_id;\r\n\r\n        IF v_user_role IN ('admin', 'coach') THEN\r\n            RETURN TRUE;\r\n        END IF;\r\n    END IF;\r\n\r\n    RETURN FALSE;\r\nEND;\r\n"
  }
]