# Rule: Define Custom Application Types

**Rule ID:** TYP002
**Applies to:** `src/types/index.ts`

**Description:** Provides guidelines for creating and managing custom, application-specific types that are composed from the base types generated by Supabase.

## The Rule

1.  All custom data-shape types used across the application **MUST** be defined in `src/types/index.ts`.
2.  These types **MUST** be composed by importing and extending the raw types from `src/types/supabase.ts`. They should not redefine properties that already exist in the generated types.
3.  Use custom types to represent specific data structures needed by the application, such as data with relationships (e.g., a team with its members) or payloads for forms (`Partial`, `Omit`, etc.).

## Rationale

While `supabase.ts` gives us the raw building blocks, our application often needs more specific data shapes (e.g., from a database join). Centralizing these custom types in `index.ts` makes them reusable and easy to manage. Composing them from the base types ensures that our application-specific models still update automatically when the database schema changes.

## Examples

### Correct

The developer creates a `TeamWithMembers` type by combining two base types. They also create a specific type for a form payload.

**File:** `src/types/index.ts`
```typescript
import { Tables } from './supabase';

// Base types imported from the source of truth
export type Team = Tables<'teams'>;
export type TeamMember = Tables<'team_members'>;
export type User = Tables<'users'>;

// Correct: A composite type for a team and its members.
// This matches the shape of data returned from a query with a join.
export type TeamWithMembers = Team & {
    team_members: TeamMember[];
};

// Correct: A type for a form payload for updating a user profile.
// It omits read-only fields and makes all other fields optional.
export type UserProfileUpdatePayload = Partial<Omit<User, 'id' | 'created_at' | 'email'>>;
```

### Incorrect

The developer manually re-defines properties inside the custom type instead of extending the base type. This breaks the link to the source of truth.

**File:** `src/types/index.ts`
```typescript
import { Tables } from './supabase';

export type TeamMember = Tables<'team_members'>;

// Incorrect: This type manually re-declares 'id' and 'name'.
// If the 'name' column in the 'teams' table is ever changed (e.g., to 'team_name'),
// this type will not update and will cause bugs.
export type TeamWithMembers = {
    id: string; // Redundant and brittle
    name: string; // Redundant and brittle
    team_members: TeamMember[];
};
```