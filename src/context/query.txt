import { useQuery } from '@tanstack/react-query';
import { fetchWorkspaceData } from './endpoint';
import type { WorkspaceData } from '@/types/workspace/index'; // Keep this type

const workspaceKeys = {
  all: ['workspace'] as const,
  details: () => [...workspaceKeys.all, 'details'] as const,
  detail: (teamId: string) => [...workspaceKeys.details(), teamId] as const,
};

/**
 * Hook for fetching all the necessary data for a given workspace view.
 * @param teamId - The ID of the workspace (team) to fetch.
 */
export const useWorkspaceDataQuery = (teamId: string | undefined) => {
  return useQuery<WorkspaceData | null, Error>({
    queryKey: workspaceKeys.detail(teamId!),
    queryFn: () => fetchWorkspaceData(teamId!),
    enabled: !!teamId, // Only runs when a teamId is provided
  });
};

// src/api/user/index.ts

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import {
  completeOnboarding,
  fetchCurrentUserProfile,
  fetchUserPlanHistory,
  fetchUserProfileDetails,
  fetchRichUserCards, // The new function
  fetchUserMeasurements,
  type UserFilters,
  setCurrentUserWorkspace,
  insertUserMeasurement,
  fetchDiscoverableUsers
} from './endpoint';
import { useAuthStore } from '@/stores/auth-store';
import type { Profile } from '@/types/index';
import type { DiscoverableUser, DiscoverableUserFilters, RichUserCardData, UserPlanHistoryItem, UserProfileDetails } from '@/types/user/index';
import { Tables, TablesInsert } from '@/types/database.types';
import { toast } from 'sonner';
import { updateUserProfile, UserProfileUpdatePayload } from '../performance/endpoint';

// --- Query Keys ---
const userKeys = {
  all: ['user'] as const,
  currentUser: () => [...userKeys.all, 'current'] as const,
  profileDetails: (userId: string) => [...userKeys.all, 'details', userId] as const,
  // Key for the new rich user card lists
  richLists: () => [...userKeys.all, 'rich', 'list'] as const,
  
  lists: () => [...userKeys.all, 'list'] as const,
  richList: (filters: UserFilters) => [...userKeys.richLists(), filters] as const,
  planHistory: (userId: string) => [...userKeys.all, 'planHistory', userId] as const, 
   measurements: () => [...userKeys.all, 'measurements'] as const, // Base key for all measurements
  userMeasurements: (userId: string) => [...userKeys.measurements(), userId] as const, // Specific user's measurements
  discoverableList: (filters: DiscoverableUserFilters) => [...userKeys.lists(), 'discoverable', filters] as const,
};

// --- Hooks ---

/**
 * Hook for fetching the current authenticated user's simple profile record.
 * This is now powered by the Zustand store.
 */
export const useCurrentUserQuery = () => {
  const { user } = useAuthStore();

  return useQuery<Profile | null, Error>({
    queryKey: userKeys.currentUser(),
    queryFn: fetchCurrentUserProfile,
    enabled: !!user,
  });
};

/**
 * Hook for fetching the complete, aggregated profile details for any user.
 */
export const useUserProfileDetailsQuery = (userId: string | undefined) => {
  return useQuery<UserProfileDetails | null, Error>({
    queryKey: userKeys.profileDetails(userId!),
    queryFn: () => fetchUserProfileDetails(userId!),
    enabled: !!userId,
  });
};

/**
 * NEW & REPLACES useDiscoverableUsersQuery: Hook for fetching rich, analytical data
 * for user/coach cards on the Explore page.
 */
export const useRichUserCardsQuery = (filters: UserFilters) => {
    return useQuery<RichUserCardData[], Error>({
      queryKey: userKeys.richList(filters),
      queryFn: () => fetchRichUserCards(filters),
    });
};

/**
 * Hook for fetching a user's complete workout plan history.
 */
export const useUserPlanHistoryQuery = (userId: string | undefined) => {
  return useQuery<UserPlanHistoryItem[], Error>({
    queryKey: userKeys.planHistory(userId!),
    queryFn: () => fetchUserPlanHistory(userId!),
    enabled: !!userId,
  });
};

/**
 * Hook for the mutation to complete the user's onboarding process.
 */
export const useCompleteOnboardingMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, void>({
    mutationFn: completeOnboarding,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.currentUser() });
    },
    onError: (error) => {
      console.error('Error completing onboarding mutation:', error);
    }
  });
};


export const useSetCurrentUserWorkspaceMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string | null>({ // <--- CHANGED: parameter can be string | null
    mutationFn: (workspaceId) => setCurrentUserWorkspace(workspaceId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['dashboard', 'summary'] });
      queryClient.invalidateQueries({ queryKey: userKeys.currentUser() });
    },
    onError: (error) => {
      console.error('Error setting current workspace:', error);
    }
  });
};

export const useUserMeasurementsQuery = (userId: string | undefined) => {
  return useQuery<Tables<'user_measurements'>[], Error>({
    queryKey: userKeys.userMeasurements(userId!),
    queryFn: () => fetchUserMeasurements(userId!),
    enabled: !!userId, // Only run if userId is available
  });
};

/**
 * NEW: Hook for inserting a new user measurement.
 */
export const useInsertUserMeasurementMutation = () => {
  const queryClient = useQueryClient();
  const { user } = useAuthStore(); // Get current user from auth store

  return useMutation<Tables<'user_measurements'>, Error, TablesInsert<'user_measurements'>>({
    mutationFn: (newMeasurementData) => insertUserMeasurement(newMeasurementData),
    onSuccess: (newRecord) => {
      // Invalidate the measurements query for the current user to refetch the updated list
      if (user?.id) {
        queryClient.invalidateQueries({ queryKey: userKeys.userMeasurements(user.id) });
      }
      toast.success('Measurement added successfully!');
    },
    onError: (error) => {
      toast.error(`Error adding measurement: ${error.message}`);
    }
  });
};

export const useUpdateUserProfileMutation = () => {
  const queryClient = useQueryClient();
  const { setProfile } = useAuthStore.getState(); // Get the action to update the auth store

  return useMutation({
    mutationFn: (payload: UserProfileUpdatePayload) => updateUserProfile(payload),
    onSuccess: (updatedProfile) => {
      toast.success("Profile updated successfully!");
      
      // Update the auth store immediately for a snappy UI response
      setProfile(updatedProfile);
      
      // Invalidate queries that depend on user data to refetch in the background
      queryClient.invalidateQueries({ queryKey: userKeys.currentUser() });
      queryClient.invalidateQueries({ queryKey: userKeys.profileDetails(updatedProfile.id) });
    },
    onError: (error) => {
      // The zod schema on the form should prevent most errors,
      // but this will catch things like a non-unique username.
      toast.error(`Update failed: ${error.message}`);
    }
  });
};

export const useDiscoverableUsersQuery = (filters: DiscoverableUserFilters) => {
  return useQuery<DiscoverableUser[], Error>({
    queryKey: userKeys.discoverableList(filters),
    queryFn: () => fetchDiscoverableUsers(filters),
    // You might want to enable/disable based on search term or dialog open state
    // For the InviteMemberDialog, it's generally enabled to fetch initially or with debounced search
    enabled: true, // or some specific condition if filtering should only occur on user input
  });
};

// src/api/team/index.ts
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
// src/api/team/index.ts
import {
    createTeam,
    fetchTeamDetails,
    fetchRichTeamCards, 
    type TeamFilters,
    fetchPendingInvitations,
    inviteMember,
    respondToInvitation
} from './endpoint';
import type { NewTeam, RichTeamCardData, Team, TeamDetails, TeamInvitationWithRelations, TeamMemberRole } from '@/types/team';

const teamKeys = {
  all: ['teams'] as const,
  lists: () => [...teamKeys.all, 'list'] as const,
  list: (filters: TeamFilters) => [...teamKeys.lists(), filters] as const,
  details: () => [...teamKeys.all, 'details'] as const,
  detail: (teamId: string) => [...teamKeys.details(), teamId] as const,
};

const teamInvitationKeys = {
    all: ['teamInvitations'] as const,
    lists: () => [...teamInvitationKeys.all, 'list'] as const,
    list: (status: string) => [...teamInvitationKeys.lists(), status] as const,
};

export const useTeamDetailsQuery = (teamId: string | undefined) => {
  return useQuery<TeamDetails | null, Error>({
    queryKey: teamKeys.detail(teamId!),
    queryFn: () => fetchTeamDetails(teamId!),
    enabled: !!teamId,
  });
};

/**
 * NEW & REPLACES OLD HOOK: Fetches rich data for team cards on the Explore page.
 */
export const useRichTeamCardsQuery = (filters: TeamFilters) => {
    return useQuery<RichTeamCardData[], Error>({
      queryKey: teamKeys.list(filters),
      queryFn: () => fetchRichTeamCards(filters),
    });
};

export const useCreateTeamMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<Team, Error, Omit<NewTeam, 'id' | 'created_by' | 'created_at' | 'updated_at'>>({
    mutationFn: (newTeamData) => createTeam(newTeamData),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: teamKeys.all });
    },
  });
};

// ... (Your invitation mutation hooks can remain the same)

export const usePendingInvitationsQuery = () => {
    return useQuery<TeamInvitationWithRelations[], Error>({
        queryKey: teamInvitationKeys.list('pending'),
        queryFn: fetchPendingInvitations,
    });
};

export const useInviteMemberMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, {
    teamId: string;
    role: TeamMemberRole;
    email?: string;
    userId?: string;
  }>({
    mutationFn: (inviteData) => inviteMember(inviteData),
    onSuccess: (_, variables) => {
      // On success, we know the DB record was created, so we can refresh the team details.
      queryClient.invalidateQueries({ queryKey: teamKeys.detail(variables.teamId) });
    },
  });
};

/**
 * **NEW:** Hook for responding to a team invitation.
 */
export const useRespondToInvitationMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, { invitationId: string, accept: boolean }>({
    mutationFn: (responseData) => respondToInvitation(responseData),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: teamInvitationKeys.lists() });
      queryClient.invalidateQueries({ queryKey: teamKeys.all });
      queryClient.invalidateQueries({ queryKey: ['user', 'details'] });
    },
  });
};

// FILE: /src/api/plan/index.ts

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import {
  fetchPlanDetails,
  fetchRichPlanCards,
  fetchPlanPerformanceList,
  startPlanForUser,
  startWorkout,
  fetchTagsByType,
  fetchSessionLog,
  createBasicPlan,
  addPlanWeek,
  updatePlanWeek,
  deletePlanWeek,
  addPlanDay,
  // --- FIX: Add missing imports for update/delete day endpoints ---
  updatePlanDay,
  deletePlanDay,
  addPlanSession,
  updatePlanSession,
  deletePlanSession,
  PlanFilters,
  addPlanSessionExercise,
  updatePlanSessionExercise,
  deletePlanSessionExercise,
  addPlanSessionExerciseSet,
  updatePlanSessionExerciseSet,
  deletePlanSessionExerciseSet,
  savePlanChanges,
  savePlanHierarchy,
  logWorkout,
  PlanGoalPayload,
  addPlanGoal,
  updatePlanGoal,
  deletePlanGoal,
  fetchPendingBaselinesForSession,
  PendingBaselineGoal,
  PlanGoalWithExercise,
  fetchPlanGoals,
  UserBaseline,
  startPlanWithBaselines,
  PlanGoalWithExerciseDetails,
} from './endpoint';
import type {
  AddPlanDayPayload,
  AddPlanWeekPayload,
  DeletePlanSessionPayload,
  DeletePlanWeekPayload,
  FullPlan,
  Plan,
  PlanDay,
  PlanPerformanceEntry,
  PlanSession,
  PlanWeek,
  RichPlanCardData,
  UpdatePlanSessionPayload,
  UpdatePlanWeekPayload,
  UserPlanStatus,
  // --- FIX: Add missing imports for day payloads ---
  UpdatePlanDayPayload,
  DeletePlanDayPayload,
  AddPlanSessionPayload,
  PlanExercise,
  AddPlanSessionExercisePayload,
  UpdatePlanSessionExercisePayload,
  DeletePlanSessionExercisePayload,
  AddPlanSessionExerciseSetPayload,
  PlanSet,
  UpdatePlanSessionExerciseSetPayload,
  DeletePlanSessionExerciseSetPayload,
  PlanHierarchy,
  LogWorkoutPayload,
} from '@/types/plan';
import type { Tag } from '@/types/exercise';
import type { Tables } from '@/types/database.types';
import { toast } from 'sonner';
import { PlanChangeset } from '@/utils/plan-diff';

const planKeys = {
  all: ['plans'] as const,
  lists: () => [...planKeys.all, 'list'] as const,
  list: (filters: PlanFilters) => [...planKeys.lists(), filters] as const,
  details: () => [...planKeys.all, 'details'] as const,
  detail: (planId: string) => [...planKeys.details(), planId] as const,
  performanceLists: () => [...planKeys.all, 'performance', 'list'] as const,
  performanceList: (planId: string) => [...planKeys.performanceLists(), planId] as const,
  sessionLogs: () => [...planKeys.all, 'sessionLog'] as const,
  sessionLog: (sessionId: string) => [...planKeys.sessionLogs(), sessionId] as const,
  teamPlans: (teamId: string) => [...planKeys.all, 'team', teamId] as const,
  planWeeks: (planId: string) => [...planKeys.detail(planId), 'weeks'] as const, // Key for specific plan's weeks
  planDays: (weekId: string) => [...planKeys.all, 'week', weekId, 'days'] as const, // Key for specific week's days
  planSessions: (dayId: string) => [...planKeys.all, 'day', dayId, 'sessions'] as const,
  // New keys for plan session exercises and sets
  planSessionExercises: (sessionId: string) => [...planKeys.all, 'session', sessionId, 'exercises'] as const,
  planSessionExerciseSets: (exerciseId: string) => [...planKeys.all, 'exercise', exerciseId, 'sets'] as const,
  pendingBaselines: (sessionId: string) => [...planKeys.all, 'pending-baselines', sessionId] as const,
  goals: (planId: string) => [...planKeys.all, 'goals', planId] as const,
};

const tagKeys = {
  all: ['tags'] as const,
  lists: () => [...tagKeys.all, 'list'] as const,
  list: (type: string) => [...tagKeys.lists(), { type }] as const,
};

// --- QUERIES ---

export const usePlanDetailsQuery = (planId: string | undefined) => {
  return useQuery<FullPlan | null, Error>({
    queryKey: planKeys.detail(planId!),
    queryFn: () => fetchPlanDetails(planId!),
    enabled: !!planId,
  });
};

export const useRichPlanCardsQuery = (filters: PlanFilters) => {
  return useQuery<RichPlanCardData[], Error>({
    queryKey: planKeys.list(filters),
    queryFn: () => fetchRichPlanCards(filters),
    placeholderData: (prev) => prev,
  });
};

export const usePlanPerformanceQuery = (planId: string | undefined) => {
  return useQuery<PlanPerformanceEntry[], Error>({
    queryKey: planKeys.performanceList(planId!),
    queryFn: () => fetchPlanPerformanceList(planId!),
    enabled: !!planId,
  });
};

/**
 * Hook for fetching a single session_log record.
 */
export const useSessionLogQuery = (sessionId: string | undefined) => {
  return useQuery<Tables<'session_logs'> | null, Error>({
    queryKey: planKeys.sessionLog(sessionId!),
    queryFn: () => fetchSessionLog(sessionId!),
    enabled: !!sessionId,
  });
};

// --- MUTATIONS ---

export const useStartPlanForUserMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<UserPlanStatus, Error, string>({
    mutationFn: (planId) => startPlanForUser(planId),
    onSuccess: (_, planId) => {
      queryClient.invalidateQueries({ queryKey: planKeys.detail(planId) });
    },
  });
};

/**
 * Hook for the mutation to start a workout session.
 */
export const useStartWorkoutMutation = () => {
  const queryClient = useQueryClient();

  return useMutation<Tables<'session_logs'>, Error, string>({
    mutationFn: (planSessionId) => startWorkout(planSessionId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: planKeys.all });
      queryClient.invalidateQueries({ queryKey: ['dashboard'] });
    },
    onError: (error) => {
      console.error("Error starting workout:", error);
    }
  });
};

/**
 * Hook for the mutation to log a completed workout.
 * On success, it invalidates dashboard and user queries to reflect the new history.
 */
export const useLogWorkoutMutation = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: LogWorkoutPayload) => logWorkout(payload),
    onSuccess: () => {
      // After a successful save, we want to refetch data that shows workout history
      // or reflects user stats. The dashboard is a great catch-all for this.
      toast.success("Workout saved successfully!");
      
      queryClient.invalidateQueries({ queryKey: ['dashboard'] });
      queryClient.invalidateQueries({ queryKey: ['user'] }); // Invalidate any user-specific queries
      
      // We don't need to invalidate the specific plan details here unless it shows
      // completion status, but invalidating the dashboard is generally enough.
    },
    onError: (error) => {
      // The toast is handled in the component, but we can log the error.
      toast.error(`Failed to save workout: ${error.message}`);
    }
  });
};

export const useTagsQuery = (tagType: string) => {
  return useQuery<Tag[], Error>({
    queryKey: tagKeys.list(tagType),
    queryFn: () => fetchTagsByType(tagType),
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
};

export const useCreateBasicPlanMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<Plan, Error, {
    p_title: string;
    p_description?: string | null;
    p_difficulty_level?: number | null;
    p_private?: boolean | null;
    p_team_id?: string | null;
  }>({
    mutationFn: (planData) => createBasicPlan(planData),
    onSuccess: (newPlan) => {
      toast.success(`Plan "${newPlan.title}" created!`);
      if (newPlan.team_id) {
        queryClient.invalidateQueries({ queryKey: planKeys.teamPlans(newPlan.team_id) });
        queryClient.invalidateQueries({ queryKey: ['teams', 'details', newPlan.team_id] });
      }
      queryClient.invalidateQueries({ queryKey: planKeys.lists() });
      queryClient.invalidateQueries({ queryKey: ['user', 'current'] });
    },
    onError: (error) => {
      toast.error(`Failed to create plan: ${error.message}`);
    }
  });
};

export const useAddPlanWeekMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<PlanWeek, Error, AddPlanWeekPayload>({
    mutationFn: (payload) => addPlanWeek(payload),
    onSuccess: (newWeek) => {
      toast.success(`Week ${newWeek.week_number} added!`);
      queryClient.invalidateQueries({ queryKey: planKeys.detail(newWeek.plan_id) });
    },
    onError: (error) => {
      toast.error(`Failed to add week: ${error.message}`);
    }
  });
};

/**
 * Hook for updating an existing plan week.
 */
export const useUpdatePlanWeekMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<PlanWeek, Error, UpdatePlanWeekPayload>({
    mutationFn: (payload) => updatePlanWeek(payload),
    onSuccess: (updatedWeek) => {
      toast.success(`Week ${updatedWeek.week_number} updated!`);
      queryClient.invalidateQueries({ queryKey: planKeys.detail(updatedWeek.plan_id) });
    },
    onError: (error) => {
      toast.error(`Failed to update week: ${error.message}`);
    }
  });
};

/**
 * Hook for deleting a plan week.
 */
export const useDeletePlanWeekMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, DeletePlanWeekPayload>({
    mutationFn: (payload) => deletePlanWeek(payload),
    onSuccess: (_, deletedWeekPayload) => {
      toast.success(`Week deleted successfully!`);
      queryClient.invalidateQueries({ queryKey: planKeys.all });
    },
    onError: (error) => {
      toast.error(`Failed to delete week: ${error.message}`);
    }
  });
};

/**
 * Hook for adding a new plan day.
 */
export const useAddPlanDayMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<PlanDay, Error, AddPlanDayPayload>({
    mutationFn: (payload) => addPlanDay(payload),
    onSuccess: (newDay) => {
      toast.success(`Day ${newDay.day_number} added!`);
      queryClient.invalidateQueries({ queryKey: planKeys.detail(newDay.plan_week_id.split('-')[0]) });
      queryClient.invalidateQueries({ queryKey: planKeys.planDays(newDay.plan_week_id) });
    },
    onError: (error) => {
      toast.error(`Failed to add day: ${error.message}`);
    }
  });
};

/**
 * NEW: Hook for updating an existing plan day.
 */
export const useUpdatePlanDayMutation = () => { // <--- ADDED HOOK
  const queryClient = useQueryClient();
  return useMutation<PlanDay, Error, UpdatePlanDayPayload>({
    mutationFn: (payload) => updatePlanDay(payload),
    onSuccess: (updatedDay) => {
      toast.success(`Day ${updatedDay.day_number} updated!`);
      queryClient.invalidateQueries({ queryKey: planKeys.detail(updatedDay.plan_week_id.split('-')[0]) });
      queryClient.invalidateQueries({ queryKey: planKeys.planDays(updatedDay.plan_week_id) });
      queryClient.invalidateQueries({ queryKey: planKeys.all }); // Fallback
    },
    onError: (error) => {
      toast.error(`Failed to update day: ${error.message}`);
    }
  });
};

/**
 * NEW: Hook for deleting a plan day.
 */
export const useDeletePlanDayMutation = () => { // <--- ADDED HOOK
  const queryClient = useQueryClient();
  return useMutation<void, Error, DeletePlanDayPayload>({
    mutationFn: (payload) => deletePlanDay(payload),
    onSuccess: (_, deletedDayPayload) => {
      toast.success(`Day deleted successfully!`);
      queryClient.invalidateQueries({ queryKey: planKeys.all }); // Broad invalidation as a fallback
    },
    onError: (error) => {
      toast.error(`Failed to delete day: ${error.message}`);
    }
  });
};

export const useUpdatePlanSessionMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<PlanSession, Error, UpdatePlanSessionPayload>({
    mutationFn: (payload) => updatePlanSession(payload),
    onSuccess: (updatedSession) => {
      toast.success(`Session ${updatedSession.order_index} updated!`);
      queryClient.invalidateQueries({ queryKey: planKeys.all });
      queryClient.invalidateQueries({ queryKey: planKeys.planSessions(updatedSession.plan_day_id) });
    },
    onError: (error) => {
      toast.error(`Failed to update session: ${error.message}`);
    }
  });
};

/**
 * NEW: Hook for deleting a plan session.
 */
export const useDeletePlanSessionMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, DeletePlanSessionPayload>({
    mutationFn: (payload) => deletePlanSession(payload),
    onSuccess: (_, deletedSessionPayload) => {
      toast.success(`Session deleted successfully!`);
      queryClient.invalidateQueries({ queryKey: planKeys.all });
    },
    onError: (error) => {
      toast.error(`Failed to delete session: ${error.message}`);
    }
  });
};



/**
 * Hook for adding a new plan day.
 */
export const useAddPlanSessionMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<PlanSession, Error, AddPlanSessionPayload>({
    mutationFn: (payload) => addPlanSession(payload),
    onSuccess: (newSession) => {
      toast.success(`Session ${newSession.order_index} added!`);
      queryClient.invalidateQueries({ queryKey: planKeys.detail(newSession.plan_day_id.split('-')[0]) });
      queryClient.invalidateQueries({ queryKey: planKeys.planSessions(newSession.plan_day_id) });
    },
    onError: (error) => {
      toast.error(`Failed to add session: ${error.message}`);
    }
  });
};
export const useAddPlanSessionExerciseMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<PlanExercise, Error, AddPlanSessionExercisePayload>({ // <--- Return type is PlanExercise
    mutationFn: (payload) => addPlanSessionExercise(payload),
    onSuccess: (newExercise) => { // newExercise is now PlanExercise
      toast.success(`Exercise "${newExercise.exercise_details.name}" added!`); // This should now work
      // Invalidate the full plan details query
      queryClient.invalidateQueries({ queryKey: planKeys.detail(newExercise.plan_session_id.split('-')[0]) }); // This assumes plan_session_id contains plan_id prefix (which it doesn't in your schema)
      // For now, let's use a broad invalidation or assume the parent will handle it.
      queryClient.invalidateQueries({ queryKey: planKeys.all }); // Broad invalidation as a fallback
      // Alternatively, the RPC could return the planId, or you could add it to payload.
      // Since the parent PlanEditPage refetches, it will eventually update.
      queryClient.invalidateQueries({ queryKey: planKeys.planSessionExercises(newExercise.plan_session_id) }); // More specific
    },
    onError: (error) => {
      toast.error(`Failed to add exercise: ${error.message}`);
    }
  });
};
/**
 * NEW: Hook for updating an existing plan session exercise.
 */
export const useUpdatePlanSessionExerciseMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<PlanExercise, Error, UpdatePlanSessionExercisePayload>({
    mutationFn: (payload) => updatePlanSessionExercise(payload),
    onSuccess: (updatedExercise) => {
      toast.success(`Exercise "${updatedExercise.exercise_details.name}" updated!`);
      queryClient.invalidateQueries({ queryKey: planKeys.all }); // Broad invalidation as a fallback
      queryClient.invalidateQueries({ queryKey: planKeys.planSessionExercises(updatedExercise.plan_session_id) });
    },
    onError: (error) => {
      toast.error(`Failed to update exercise: ${error.message}`);
    }
  });
};

/**
 * NEW: Hook for deleting a plan session exercise.
 */
export const useDeletePlanSessionExerciseMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, DeletePlanSessionExercisePayload>({
    mutationFn: (payload) => deletePlanSessionExercise(payload),
    onSuccess: (_, deletedExercisePayload) => {
      toast.success(`Exercise deleted successfully!`);
      queryClient.invalidateQueries({ queryKey: planKeys.all }); // Broad invalidation as a fallback
    },
    onError: (error) => {
      toast.error(`Failed to delete exercise: ${error.message}`);
    }
  });
};

export const useAddPlanSessionExerciseSetMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<PlanSet, Error, AddPlanSessionExerciseSetPayload>({
    mutationFn: (payload) => addPlanSessionExerciseSet(payload),
    onSuccess: (newSet) => {
      toast.success(`Set ${newSet.set_number} added!`);
      // Invalidate the full plan details query (will cause entire hierarchy to refetch)
      queryClient.invalidateQueries({ queryKey: planKeys.detail(newSet.plan_session_exercise_id.split('-')[0]) }); // This still needs plan_id
      // For now, simpler invalidation.
      queryClient.invalidateQueries({ queryKey: planKeys.all }); // Broad invalidation as a fallback
      queryClient.invalidateQueries({ queryKey: planKeys.planSessionExerciseSets(newSet.plan_session_exercise_id) });
    },
    onError: (error) => {
      toast.error(`Failed to add set: ${error.message}`);
    }
  });
};


export const useSavePlanChangesMutation = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (changeset: PlanChangeset) => savePlanChanges(changeset),
    onSuccess: (data, variables) => {
      toast.success("Plan saved successfully!");
      // After a successful save, we MUST refetch the plan details
      // to get the real database IDs and latest data.
      queryClient.invalidateQueries({ queryKey: planKeys.detail(variables.planId) });
    },
    onError: (error) => {
      // The toast is already handled in the component, but you can add more logic here.
      console.error("Save plan mutation error:", error);
    }
  });
};

/**
 * NEW: Hook for updating an existing plan session exercise set.
 */
export const useUpdatePlanSessionExerciseSetMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<PlanSet, Error, UpdatePlanSessionExerciseSetPayload>({
    mutationFn: (payload) => updatePlanSessionExerciseSet(payload),
    onSuccess: (updatedSet) => {
      toast.success(`Set ${updatedSet.set_number} updated!`);
      queryClient.invalidateQueries({ queryKey: planKeys.all }); // Broad invalidation as a fallback
      queryClient.invalidateQueries({ queryKey: planKeys.planSessionExerciseSets(updatedSet.plan_session_exercise_id) });
    },
    onError: (error) => {
      toast.error(`Failed to update set: ${error.message}`);
    }
  });
};

/**
 * NEW: Hook for deleting a plan session exercise set.
 */
export const useDeletePlanSessionExerciseSetMutation = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, DeletePlanSessionExerciseSetPayload>({
    mutationFn: (payload) => deletePlanSessionExerciseSet(payload),
    onSuccess: (_, deletedSetPayload) => {
      toast.success(`Set deleted successfully!`);
      queryClient.invalidateQueries({ queryKey: planKeys.all }); // Broad invalidation as a fallback
    },
    onError: (error) => {
      toast.error(`Failed to delete set: ${error.message}`);
    }
  });
};

export const useSavePlanHierarchyMutation = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: { planId: string; hierarchy: PlanHierarchy }) => savePlanHierarchy(payload),
    onSuccess: (data, variables) => {
      // After a successful save, we MUST refetch the plan details.
      // This gets the real DB IDs for any new items and confirms the structure.
      queryClient.invalidateQueries({ queryKey: planKeys.detail(variables.planId) });
    },
    onError: (error) => {
      // The toast is handled in the component, but we can log here.
      console.error("Save plan hierarchy mutation error:", error);
    }
  });
};

// --- ADD THESE THREE NEW MUTATION HOOKS ---

export const useAddPlanGoalMutation = (planId: string) => {
  const queryClient = useQueryClient();
  return useMutation({
    // --- THIS LINE IS THE FIX ---
    // The `payload` is now correctly typed as our new, complete PlanGoalPayload
    mutationFn: (payload: PlanGoalPayload) => addPlanGoal(planId, payload),
    onSuccess: () => {
      toast.success("Goal added!");
      queryClient.invalidateQueries({ queryKey: planKeys.detail(planId) });
    },
    onError: (err) => toast.error(`Failed to add goal: ${err.message}`),
  });
};

export const useUpdatePlanGoalMutation = (planId: string) => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (variables: { goalId: string, payload: PlanGoalPayload }) => updatePlanGoal(variables.goalId, variables.payload),
    onSuccess: () => {
      toast.success("Goal updated!");
      queryClient.invalidateQueries({ queryKey: planKeys.detail(planId) });
    },
    onError: (err) => toast.error(`Failed to update goal: ${err.message}`),
  });
};

export const useDeletePlanGoalMutation = (planId: string) => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (goalId: string) => deletePlanGoal(goalId),
    onSuccess: () => {
      toast.success("Goal deleted!");
      queryClient.invalidateQueries({ queryKey: planKeys.detail(planId) });
    },
    onError: (err) => toast.error(`Failed to delete goal: ${err.message}`),
  });
};


// --- ADD NEW HOOK ---
export const usePendingBaselinesQuery = (planSessionId: string | undefined, options: { enabled: boolean }) => {
    return useQuery<PendingBaselineGoal[], Error>({
        queryKey: planKeys.pendingBaselines(planSessionId!),
        queryFn: () => fetchPendingBaselinesForSession(planSessionId!),
        enabled: !!planSessionId && options.enabled,
    });
};


// --- THIS HOOK NOW USES THE CORRECT TYPE ---
export const usePlanGoalsQuery = (planId: string | undefined, options?: { enabled?: boolean }) => {
    return useQuery<PlanGoalWithExerciseDetails[], Error>({
        queryKey: planKeys.goals(planId!),
        queryFn: () => fetchPlanGoals(planId!),
        enabled: !!planId && (options?.enabled ?? true),
    });
};

export const useStartPlanWithBaselinesMutation = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (variables: { planId: string; baselines: UserBaseline[] }) => 
            startPlanWithBaselines(variables.planId, variables.baselines),
        onSuccess: (data, variables) => {
            queryClient.invalidateQueries({ queryKey: planKeys.detail(variables.planId) });
        },
    });
};

// FILE: src/api/performance/index.ts

import { useMutation, useQuery } from '@tanstack/react-query';
import { fetchPlanPerformanceDetails, fetchUserLogbook, fetchUserPlanPerformanceList, fetchUserWorkoutDates, setGoalBaseline } from './endpoint';
import type { LogbookEntry, PlanPerformanceDetails, UserPlanPerformanceData } from './endpoint';
import { queryClient } from '@/lib/query-client';
import { toast } from 'sonner';

// --- Query Keys ---
const performanceKeys = {
  all: ['performance'] as const,
  lists: () => [...performanceKeys.all, 'list'] as const,
  list: (userId: string) => [...performanceKeys.lists(), { userId }] as const,
  dates: () => [...performanceKeys.all, 'dates'] as const, // <-- NEW
  dateList: (userId: string) => [...performanceKeys.dates(), { userId }], // <-- NEW
  logbooks: () => [...performanceKeys.all, 'logbook'] as const, // <-- NEW
  logbook: (userId: string) => [...performanceKeys.logbooks(), { userId }], // <-- NEW
  details: () => [...performanceKeys.all, 'detail'] as const, // <-- NEW
  detail: (id: string) => [...performanceKeys.details(), id], // <-- NEW
};


// --- The Hook ---

/**
 * Hook to fetch the performance summary list for all of a user's plans.
 * @param userId The ID of the user. Hook is disabled if userId is not provided.
 */
export const useUserPlanPerformanceListQuery = (userId: string | undefined) => {
  return useQuery<UserPlanPerformanceData[], Error>({
    queryKey: performanceKeys.list(userId!),
    queryFn: () => fetchUserPlanPerformanceList(userId!),
    enabled: !!userId, // The query will only run if a userId is provided.
  });
};

/**
 * Hook to fetch the list of all workout dates for a user, for use in a heatmap.
 * @param userId The ID of the user.
 */
export const useUserWorkoutDatesQuery = (userId: string | undefined) => {
    return useQuery<{ workout_date: string }[], Error>({
        queryKey: performanceKeys.dateList(userId!),
        queryFn: () => fetchUserWorkoutDates(userId!),
        enabled: !!userId,
    });
};


// --- ADD THIS NEW HOOK ---
export const useUserLogbookQuery = (userId: string | undefined) => {
  return useQuery<LogbookEntry[], Error>({
    queryKey: performanceKeys.logbook(userId!),
    queryFn: () => fetchUserLogbook(userId!),
    enabled: !!userId,
  });
};

/**
 * Hook for the mutation to set a user's baseline for a specific plan goal.
 * @param userId The ID of the user, used for query invalidation.
 */
export const useSetGoalBaselineMutation = (userId: string) => {

  return useMutation({
    mutationFn: (payload: { progressId: string; baselineValue: number }) => setGoalBaseline(payload),
    onSuccess: () => {
      toast.success("Baseline saved! Your goal is now active.");
      // Invalidate the main performance list to refetch the updated goal status
      queryClient.invalidateQueries({ queryKey: performanceKeys.list(userId) });
      // You might also invalidate a more specific query for the plan drill-down page later
    },
    onError: (error) => {
      toast.error(`Failed to save baseline: ${error.message}`);
    }
  });
};

export const usePlanPerformanceDetailsQuery = (userPlanStatusId: string | undefined) => {
  return useQuery<PlanPerformanceDetails | null, Error>({
    queryKey: performanceKeys.detail(userPlanStatusId!),
    queryFn: () => fetchPlanPerformanceDetails(userPlanStatusId!),
    enabled: !!userPlanStatusId,
  });
};

// FILE: /src/api/exercise/index.ts

import { useQuery } from '@tanstack/react-query';
import {
    fetchExerciseDetails,
    fetchFilteredExercisesWithDetails,
    type ExerciseFilters
} from './endpoint';
import type { ExerciseWithDetails, ExerciseWithMuscles } from '@/types/exercise';

const exerciseKeys = {
  all: ['exercises'] as const,
  lists: () => [...exerciseKeys.all, 'list'] as const,
  list: (filters: ExerciseFilters) => [...exerciseKeys.lists(), filters] as const,
  details: () => [...exerciseKeys.all, 'details'] as const,
  detail: (exerciseId: string) => [...exerciseKeys.details(), exerciseId] as const,
};

/**
 * Hook for fetching a filtered list of exercises, including their muscle data.
 */
export const useFilteredExercisesQuery = (filters: ExerciseFilters) => {
  return useQuery<ExerciseWithMuscles[], Error>({
    queryKey: exerciseKeys.list(filters),
    queryFn: () => fetchFilteredExercisesWithDetails(filters),
  });
};

/**
 * Hook for fetching the complete details of a single exercise.
 */
export const useExerciseDetailsQuery = (exerciseId: string | undefined) => {
  return useQuery<ExerciseWithDetails | null, Error>({
    queryKey: exerciseKeys.detail(exerciseId!),
    queryFn: () => fetchExerciseDetails(exerciseId!),
    enabled: !!exerciseId,
  });
};

import { useQuery } from '@tanstack/react-query';
import { fetchDashboardSummary } from './endpoint';
import type { DashboardSummary } from '@/types/dashboard/index';

const dashboardKeys = {
  all: ['dashboard'] as const,
  summary: () => [...dashboardKeys.all, 'summary'] as const,
};

/**
 * Hook for fetching the complete summary data for the user's main dashboard.
 */
export const useDashboardSummaryQuery = () => {
  return useQuery<DashboardSummary | null, Error>({
    queryKey: dashboardKeys.summary(),
    queryFn: fetchDashboardSummary,
  });
};